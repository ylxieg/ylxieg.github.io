<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2019年面试题(基础)以及答案</title>
      <link href="/2019/03/24/2019%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98(%E5%9F%BA%E7%A1%80)%E4%BB%A5%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <content type="html"><![CDATA[<h4 id="面向对象基础面试题"><a href="#面向对象基础面试题" class="headerlink" title="面向对象基础面试题"></a>面向对象基础面试题</h4><ol><li>面向对象的几个设计原则？<ul><li>单一职责、开闭原则、里氏替换原则、依赖导致原则、接口隔离原则、迪米特原则(设计模式之禅第一部分)</li></ul></li><li>Hash表的实现？<ul><li>哈希表（hash table，也叫散列表），是根据键（key）直接访问访问在内存储存位置的数据结构。哈希表本质是一个数组，数组中的每一个元素成为一个箱子，箱子中存放的是键值对。根据下标index从数组中取value。关键是如何获取index，这就需要一个固定的函数（哈希函数），将key转换成index。不论哈希函数设计的如何完美，都可能出现不同的key经过hash处理后得到相同的hash值，这时候就需要处理哈希冲突。（拉链法和开放定址线性探测法）</li></ul></li><li>什么是进程和线程？有什么区别？<ul><li>线程是轻型进程，是CPU独立运行和独立调度的基本单位；</li><li>进程是程序的一次执行，是资源分配的基本单位；</li><li>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。系统在运行时会为每个进程分配内存，而不会为线程分配。</li></ul></li><li>内存的几大区域？各自的职能？（由高地址向低地址）<ul><li>栈区：存放局部变量和函数的实参，编译器自动分配并释放。（速度快。不会产生内存碎片，可用空间小）</li><li>堆区：OC中使用new方法创建的对象，程序员手动申请并释放。（alloc分配的内存，速度慢，容易产生内存碎片。但是使用方便）</li><li>静态区（全局区）：用来存放没有初始化的全局变量和静态变量。（Xcode8中全局变量和静态变量都存在静态区/BSS断，不管是否初始化）</li><li>常量区（数据段）：用来存储已经初始化的全局变量，静态变量，常量数据，程序结束后由系统释放。（Xcode8存储常量）</li><li>代码区：代码的二进制文件/用来存储程序的代码指令。</li></ul></li><li>架构、框架和设计模式的区别？<ul><li>架构：是一种已经提供了关系布局的骨架，它是由关系设计而来的，无论设计与使用的人，至少要了解它的作用，特别是关系。</li><li>框架：是一种工具(就是一些复用的代码)，它不是学问，基于设计模式的一种特定实现，它更多是面向程序员提供某些已经实现的功能，和有限度的关系管理。</li><li>设计模式：是一种对象关系管理与设计的学问，一种思想，它不属于任何一种语言。因此设计模式出现后，衡量一个程序员的水平，其中有一个领域就是对设计模式的了解程度。它代表了你归纳、组织等和代码与对象关系的设计能力。</li></ul></li><li>谈一下你理解的MVC、MVVM、MVP和VIPER？<ul><li>MVC：M(业务模型层)、V(展示层)、C(控制器层) 是由Controller驱动的，Controller持有View，并响应View上的交互事件，根据交互调用不同的Model方法取得反馈数据，再将数据传递给View展示。达到了代码复用、易拓展、可维护的效果，也产生了C层不易测试、业务逻辑和业务展示强耦合</li><li>MVP：是由View驱动的，View层持有一个对应的Presenter的引用，View上的交互事件首先会调用Presenter提供的接口，然后Presenter调用Model提供的方法取得数据，最后Presenter将取得的数据传递到View上展示。将业务逻辑与业务展示做了一层隔离，业务逻辑都转移到P层，减少了耦合，对比C层更容易测试。但也导致VP之间的数据交互太繁琐</li><li>MVVM：MVVM各层的职责和MVP的类似，VM对应P层，只是在MVVM的View层多了数据绑定的操作。创建了一个视图抽象。将业务逻辑和业务展示分离，方便测试并且逻辑结构清晰。但数据绑定使得 Bug 很难被调试。双向绑定也使类很难被重用。</li><li>VIPER：VIPER彻底弱化了VC的概念，让VC变成了真正意义上的View。把VC的职责进行了彻底的拆分，分散到各个子层里面了，做到了每个模块都可以单独测试和复用，但是也导致了代码过多、逻辑比较绕的问题。</li></ul></li></ol><h4 id="iOS-UI基础"><a href="#iOS-UI基础" class="headerlink" title="iOS UI基础"></a>iOS UI基础</h4><ol><li>UIView和CALayer的区别？（CALayer的逻辑树、动画树和显示树）<ul><li>UIView可以响应事件处理，CALayer不可以。UIView是CALayer的delegate</li><li>UIView主要是对显示内容的管理，而CALayer主要侧重显示内容的绘制。</li><li>在做iOS动画的时候，修改非RootLayer的属性（位置、颜色等）会默认产生隐式动画，而修改UIView不会。</li><li>逻辑树：就是代码里可以操纵的，例如更改layer的属性等就在这里。</li><li>动画树：这是一个中间层，系统在这一层上更改属性，进行各种渲染操作。</li><li>显示树：就是当前正被显示在屏幕上的内容。</li></ul></li><li>loadView是干嘛用的？<ul><li>每次访问UIViewController的view(self.view,controller.view)或者view为nil，loadView方法就会被调用。</li><li>loadView方法是用来创建UIViewController的View的</li><li>[super loadView]会去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view，如果没有找到xib文件，就会创建一个空白的UIView并赋值给UIViewController的view属性。</li></ul></li><li>layoutIfNeeded、layoutSubviews和setNeedsLayout的区别？<ul><li>layoutSubviews:调用addSubview、设置并改变视图的frame属性、滑动UIScrollView及继承UIScrollView的控件、旋转屏幕时都会触发layoutSubviews方法</li><li>layoutIfNeet:如果有需要刷新的标记，立即调用layoutSubviews进行布局。(如果没有标记不会调用layoutSubviews)</li><li>setNeedsLayout:标记为需要重新布局，异步调用layoutIfNeed刷新布局，不立即刷新，在下一轮RunLoop结束前刷新，对于这一轮RunLoop之内的所有布局和UI上的更新指挥刷新一次，layoutSubviews一定会被调用。</li></ul></li><li>iOS的响应链？什么情况会影响响应链？<ul><li>响应链是由一串UIResponder对象链接，当APP接收事件时，UIKit自动引导事件到最合适的响应者对象，也叫做第一响应者。事件由上往下传递，直到能响应事件为止。重写hitTest:withEvent会影响响应链。</li><li>运动事件相关的加速度计、陀螺仪、磁强计都不属于响应者链。而是由CoreMotion传递事件给你指定的对象。</li></ul></li><li>说几种给UIImageView添加圆角的方式？<ul><li>通过设置UIView的layer来设置圆角</li><li>通过Graphics绘制图片，将图片裁剪成圆角</li><li>通过贝塞尔曲线绘制圆角</li><li>通过mask遮罩，在原图片上盖一张圆形图片</li></ul></li><li>iOS中实现动画的方式有哪些？(详见iOS动画核心技术与案例)<ul><li>显示层动画(UIView动画、CALayer关键帧、逐帧动画、Gif动画)</li><li>内容层动画(Core Animation系列动画、CAEmitterCell粒子动画等)</li><li>3D动画(CATransform3D动画、Cover Flow3D效果)</li><li>转场动画(CATransition动画)</li></ul></li><li>使用drawRect有什么影响？<ul><li>在drawRect方法中创建一个新的对象，重复执行[self addSubView:view];会导致对象重复创建，<strong>引起视图错误，内存暴增</strong>。主动调用setNeedsDisplay也会调drawRect方法</li><li>绘制图形性能的优化最好的办法就是不去绘制。</li><li>利用专有图层代替绘图需求</li><li>必须用到绘图时尽量缩小视图面积。并尽量降低重绘频率。</li><li>异步绘制，计算内容，提前在其他线程绘制图片。在主线程中直接设置图片。</li></ul></li></ol><h4 id="OC基础"><a href="#OC基础" class="headerlink" title="OC基础"></a>OC基础</h4><ol><li>我们说的Objective-C是动态运行时语言是什么意思？<ul><li>OC的动态运行时是指OC具有动态类型、动态绑定和动态加载的特性。</li><li>动态类型：如id类型，运行时才确定对象的所属类。静态类型是强类型，动态类型是弱类型。</li><li>动态绑定：使程序直到运行时才确定调用对象的实际方法。</li><li>动态加载：让程序在运行时添加代码块及其他资源。用户可以根据需要执行一些可执行代码和资源，而不是在启动时就加载所有组件。</li></ul></li><li>static和const的区别？<ul><li>static:修饰局部变量只初始化一次，该变量在程序运行期间不释放。分配在静态存储区。</li><li>static:全局变量本身就是静态存储方式，以static修饰以后还是静态存储方式。区别在于非静态全局变量的作用域是整个源程序，而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效。在同一个源程序的其他文件中不能使用。</li><li>const:仅仅用来修饰右边的变量，被const修饰的变量是只读的。</li></ul></li><li>为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?<ul><li>防止循环引用。(controller—&gt;tableView–&gt;delegate—&gt;controller)</li><li>delegate偏重与用户交互的回调，dataSource侧重数据处理的回调。</li><li>block运行成本高，出栈需要将使用的数据从栈内存拷贝到堆内存，使用完或者block置为nil才销毁。delegate只是保存了一个对象指针，直接回调，没有额外消耗。</li><li>block的代码可读性更好，直接实现就好了。而delegate的实现比较麻烦，需要声明协议，声明代理，遵守协议，实现协议方法。</li><li>建议优先使用block，如果回调的状态很多，调用次数频繁。建议使用delegate。</li><li>block和delegate都各有优点。所以我们要理解区分使用场景。应用合适的回调方式。</li></ul></li><li>属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？<ul><li>属性的实质@property = ivar + getter + setter;</li><li>利用class_copyPropertyList查看类的所有属性</li><li>利用class_copyIvarList查看类的所有成员变量</li><li>利用class_copyMethodList查看类的所有方法。</li></ul></li><li>属性的默认关键字是什么？<ul><li>automatic、readwrite、strong</li></ul></li><li>NSString为什么要用copy关键字，如果用strong会有什么问题？（注意：这里没有说用strong就一定不行。使用copy和strong是看情况而定的）<ul><li>copy修饰的是深拷贝，改变源字符串，不影响copy的属性内容。</li><li>strong修饰的属性就随着源字符串改变而改变了。</li></ul></li><li>如何令自己所写的对象具有拷贝功能?<ul><li>实现NSCoping协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying与 NSMutableCopying协议。</li></ul></li><li>简述kvo、kvc、Delegate他们之间的区别？<ul><li>代理的效率比通知要高。</li><li>代理比通知更加直接。</li><li>kvo和通知，代理一样，都是负责通信的。kvo和通知没有返回值，而代理有返回值。</li><li>代理是一对一，通知，kvo是一对多。</li></ul></li><li>include与#import的区别？#import与@class的区别？<ul><li>include 是C预言中用来引用的关键字。</li><li>import 是OC中用来代替 include的关键字。#import确保了同一个文件只能被导入一次，从而别面了使用 #include容易引起的重复导入问题。</li><li>@class只是告诉编译器，后边遇到的这名称是类名，至于这个类是如何实现的暂时不考虑，用来解决线程锁死的问题。</li></ul></li><li>nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？<ul><li>nonatomic和atomic用来决定编译器生成的getter和setter操作是否为原子。</li><li>atomic不是绝对的线程安全。因为atomic的本意是指属性的存取方法是线程安全的，不是保证整个对象是线程安全的。在线程中操作对象加锁。</li></ul></li><li>Objective-C与C、C+++之间的联系和区别？<ul><li>OC与C的区别：OC中兼容C两者可以混合编程。OC是面向对象的，有类，对象的概念，C却木有。</li><li>C是面向过程的语言。</li><li>OC与C++的区别：</li><li>继承。OC不可以多重继承，C++却可以</li><li>函数调用。OC需要通过消息传递机制调用函数，C++却可以直接调用</li><li>定型。OC是动态定型。C++是等着你去找他。是静态类型。</li><li>接口。OC采用的是protocol协议。C++采用虚函数的形式。</li><li>方法重载。OC不允许有同一个类中出现两个相同的方法名。C++中允许两个方法名相同。</li></ul></li><li>UICollectionView自定义layout如何实现？<ul><li>继承UICollectionViewLayout之后只需要重载几个提供布局核心特性的方法，其他方法只需按情况重载即可，</li><li>覆写prepareLayout方法，并在里面事先就计算好必要的布局信息并存储起来。</li><li>collectionViewContentSize方法基于初始计算，返回整体内容区域的size</li><li>layoutAttributesForElementsInRect:方法返回指定区域中cells和views等布局属性</li><li>layoutAttributesForItemAtIndexPath设置itemSize的大小，cell之间的间距等。</li></ul></li><li>进程和线程的区别？同步异步的区别？并行和并发的区别？<ul><li>进程：是资源的分配和调度的一个独立单元，</li><li>线程：是CPU调度的基本单元</li><li>同步：是顺序执行，执行完当前的任务再执行下一个，需要等待、协调运行。</li><li>异步：是彼此独立，多个任务之间不必要互相等待，只要CPU空闲，就可以同时执行多个任务，不需要等待其它任务的完成。</li><li>并发：指一个时间段中几个程序都处于已启动到运行完毕之间，且这几个程序都是在同一个处理机上运行。 </li><li>并行：并行是针对多处理器而言的，指同时发生多个并发事件</li></ul></li><li>线程间通信？<ul><li>performSelectorOnMainThread:withObject:waitUntilDone</li><li>performSelector:onThread:withObject:waitUntilDone</li><li>CGD:dispatch_async异步执行任务再回到getmainqueue主线程</li></ul></li><li>GCD的一些常用的函数？（group，barrier，信号量，线程同步）<ul><li>dispatch_sync同步</li><li>dispatch_async异步</li><li>dispatch_barrier_async栅栏</li><li>dispatch_after定时器</li><li>dispatch_once执行一次</li><li>dispatch_group、dispatch_group_notify</li><li>dispatch_group_enter、dispatch_group_leave</li><li>dispatch_semaphore(保持线程同步，将异步执行任务转换为同步执行任务/保证线程安全，为线程加锁)</li></ul></li><li>如何访问并修改一个类的私有属性？<ul><li>通过KVC访问并修改。</li><li>通过runtime访问并修改。</li></ul></li><li>数据持久化的几个方案？</li></ol><ul><li>plist文件、preference偏好设置、归档、SQLite3(fmdb)、CoreData、Realm </li></ul><ol><li>说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？<ul><li>从前台到后台:applicationWillResignActive、applicationDidEnterBackground</li><li>从后台到前台:applicationWillEnterForeground、applicationDidBecomeActive</li><li>第一次启动:application:didFinishLaunchingWithOptions、applicationDidBecomeActive</li><li>通过URLScheme打开App:applicationWillEnterForeground、application:openURL:sourceApplication:annotation、applicationDidBecomeActive</li></ul></li><li>NSCache优于NSDictionary的几点？<ul><li>NSCache是线程安全的。</li><li>当内存不足时NSCach会自动释放内存。</li><li>NSCache可以指定缓存的限额，当缓存超出限额自动释放内存</li></ul></li><li>知不知道Designated Initializer？使用它的时候有什么需要注意的问题？<ul><li>指定初始化方法，只能标识init命名的方法。</li><li>子类指定了新的初始化器，那么在这个初始化器内部必须调用父类的Designated Initializer。并且需要重写父类的Designated Initializer，将其指向子类新的初始化器。也可以用NS_UNAVAILABLE宏禁用父类的初始化器。</li><li>子类没有指定新的初始化器，也可以重写父类的Designated Initializer，但需要调用直接父类的Designated Initializer。</li><li><a href="http://www.cocoachina.com/programmer/20140421/8204.html" target="_blank" rel="noopener">正确编写Designated Initializer的几个原则</a></li></ul></li><li>实现description方法能取到什么效果？<ul><li>不实现会打印&lt;类名：内存地址&gt;</li><li>实现会打印description的描述信息</li></ul></li><li>objc使用什么机制管理对象内存？(Objective-C高级编程 iOS与OS X多线程和内存管理)<ul><li>自动引用计数</li><li>自己生成的对象自己持有（alloc/new/copy/mutableCopy…）</li><li>非自己生成的对象自己也能持有(retain)</li><li>不再需要自己持有的对象时释放(release)</li><li>非自己持有的对象无法释放(dealloc)</li></ul></li><li>如何绘制UIView?<br>绘制一个UIView最灵活的方法就是由它自己完成绘制。实际上你不是绘制一个UIView，而是子类化一个UIView并赋予绘制自己的能力。当一个UIView需要执行绘制操作时，drawRect：方法就会被调用，覆盖此方法让你获得绘图操作的机会。当drawRect：方法被调用，当前图形的上下文也被设置为属于视图的图形上下文，你可以使用Core Graphic或者UIKit提供的方法将图形画在该上下文中。</li><li>gcd产生死锁的原因及解锁的方法<br>产生死锁的必要条件：1.互斥条件，2.请求与保持条件，3.不剥夺条件，4.循环等待条件。<br>解决办法：采用异步执行block。</li><li>get请求与post请求的区别<ul><li>get是向服务器发索取数据的一种请求，而post是向服务器提交数据的一种请求</li><li>get没有请求体，post有请求体</li><li>get请求的数据会暴露在地址栏中，而post请求不会，所以post请求的安全性比get请求号</li><li>get请求对url长度有限制，而post请求对url长度理论上是不会收限制的，但是实际上各个服务器会规定对post提交数据大小进行限制。</li></ul></li><li>谈谈你对多线程开发的理解？ios中有几种实现多线程的方法？<ul><li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片，视频的下载；</li><li>发挥多核处理器的优势，并发执行让系统运行的更快，更流畅，用户体验更好；</li><li>大量的线程降低代码的可读性；</li><li>更多的线程需要更多的内存空间；</li><li>当多个线程对同一个资源出现争夺的时候要注意线程安全的问题。</li><li>ios有3种多线程编程的技术：1.NSThread，2.NSOperationQueue，3.gcd；</li></ul></li><li>XMPP工作原理；xmpp系统特点<ul><li>工作原理：</li><li>所有从一个client到另一个client的jabber消息和数据都要通过xmpp server</li><li>client链接到server</li><li>server利用本地目录系统的证书对其认证</li><li>server查找，连接并进行相互认证</li><li>client间进行交互特点：</li><li>客户机/服务器通信模式；</li><li>分布式网络；</li><li>简单的客户端；</li><li>XML的数据格式；</li></ul></li><li>地图的定位是怎么实现的？<ul><li>导入了CoreLocation.framework</li><li>ios8以后，如果需要使用定位功能，就需要请求用户授权，在首次运行时会弹框提示</li><li>通过本机自带的gps获取位置信息(即经纬度)</li></ul></li><li>苹果内购实现流程<ul><li>程序通过bundle存储的plist文件得到产品标识符的列表。</li><li>程序向App Store发送请求，得到产品的信息。</li><li>App Store返回产品信息。</li><li>程序把返回的产品信息显示给用户（App的store界面）</li><li>用户选择某个产品</li><li>程序向App Store发送支付请求</li><li>App Store处理支付请求并返回交易完成信息。</li><li>App获取信息并提供内容给用户。</li></ul></li><li>支付宝，微信等相关类型的sdk的集成<ul><li>在支付宝开发平台创建应用并获取APPID</li><li>配置密钥</li><li>集成并配置SDK</li><li>调用接口（如交易查询接口，交易退款接口）</li></ul></li><li>生成二维码的步骤<ul><li>使用CIFilter滤镜类生成二维码</li><li>对生成的二维码进行加工，使其更清晰</li><li>自定义二维码背景色、填充色</li><li>自定义定位角标</li><li>在二维码中心插入小图片</li></ul></li><li>在使用XMPP的时候有没有什么困难<ul><li>发送附件（图片，语音，文档…）时比较麻烦</li><li>XMPP框架没有提供发送附件的功能，需要自己实现</li><li>实现方法，把文件上传到文件服务器，上传成功后获取文件保存路径，再把附件的路径发送给好友</li></ul></li><li>是否使用过环信，简单的说下环信的实现原理<ul><li>环信是一个即时通讯的服务提供商</li><li>环信使用的是XMPP协议，它是再XMPP的基础上进行二次开发，对服务器Openfire和客户端进行功能模型的添加和客户端SDK的封装，环信的本质还是使用XMPP，基于Socket的网络通信</li><li>环信内部实现了数据缓存，会把聊天记录添加到数据库，把附件（如音频文件，图片文件）下载到本地，使程序员更多时间是花到用户体验体验上。</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何优化复杂tableView卡顿问题？</title>
      <link href="/2019/03/11/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%A4%8D%E6%9D%82tableView%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h4 id="导致tableView卡顿的原因："><a href="#导致tableView卡顿的原因：" class="headerlink" title="导致tableView卡顿的原因："></a>导致tableView卡顿的原因：</h4><ol><li>cellForRowAtIndexPath:方法中处理了过多业务</li><li>cell的subview层级太复杂，做了大量透明处理  </li><li>cell的height动态变化时计算方式不对</li></ol><h4 id="优化tableView："><a href="#优化tableView：" class="headerlink" title="优化tableView："></a>优化tableView：</h4><ol><li>cell的行高不是固定值，需要计算，则要尽可能缓存行高值，避免重复计算行高。因为 heightForRowAtIndexPath:是调用最频繁的方法。</li><li>滑动时按需加载，这个在大量图片展示，网络加载的时候很管用!(SDWebImage 已经实现异 步加载，配合这条性能杠杠的)。</li><li>正确使用 reuseIdentifier 来重用 Cells</li><li>尽量少用或不用透明图层</li><li>如果 Cell 内现实的内容来自 web，使用异步加载，缓存请求结果</li><li>减少 subviews 的数量</li><li>在 heightForRowAtIndexPath:中尽量不使用 cellForRowAtIndexPath:，如果你需要用到它， 只用一次然后缓存结果</li><li>所有的子视图都预先创建，如果不需要显示可以设置 hidden，尽量少动态给 Cell 添加 View </li><li>颜色不要使用 alph</li><li>栅格化，</li><li>cell 异步加载图片以及缓存 </li><li>cell 的 subViews 的各级 opaque 值要设成 YES，尽量不要包含透明的子 View<br>opaque 用于辅助绘图系统，表示 UIView 是否透明。在不透明的情况下，渲染视图时需要快速 地渲染，以􏰀高性能。渲染最慢的操作之一是混合(blending)。􏰀高性能的方法是减少混合操 作的次数，其实就是 GPU 的不合理使用，这是硬件来完成的(混合操作由 GPU 来执行，因为这 个硬件就是用来做混合操作的，当然不只是混合)。 优化混合操作的关键点是在平衡 CPU 和 GPU 的负载。还有就是 cell 的 layer 的 shouldRasterize 要设成 YES。</li><li>不要将 tableview 的背景颜色设置成一个图片。这回严重影响 UITableView 的滑动速度。在 限时免费搜索里，我曾经翻过一个错误:self.tableView_.backgroundColor = [UIColorcolorWithPatternImage:[UIImageimageNamed:@”background.png”]]; 通过这种方式 设置 UITableView 的背景颜色会严重影响 UTIableView 的滑动流畅性。修改成 self.tableView_.backgroundColor = [UIColor clearColor];之后，fps 从 43 上升到 60 左右。 滑动比较流畅。</li><li>异步绘制</li></ol><blockquote><p>(1) 在绘制字符串时，尽可能使用 drawAtPoint: withFont:，而不要使用更复杂的 drawAtPoint:(CGPoint)point forWidth:(CGFloat)width withFont:(UIFont *)font lineBreakMode:(UILineBreakMode)lineBreakMode; 如果要绘制过长的字符串，建议自己先截 断，然后使用 drawAtPoint: withFont:方法绘制。<br>(2) 在绘制图片时，尽量使用 drawAtPoint，而不要使用 drawInRect。drawInRect 如果在绘 制过程中对图片进行放缩，会特别消耗 CPU。<br>(3) 其实，最快的绘制就是你不要做任何绘制。有时通过 UIGraphicsBeginImageContextWithOptions() 或者 CGBitmapContextCeate() 创建位图会显 得更有意义，从位图上面抓取图像，并设置为 CALayer 的内容。如果你必须实现 -drawRect:，并且你必须绘制大量的东西，这将占用时间。<br>(4) 如果绘制 cell 过程中，需要下载 cell 中的图片，建议在绘制 cell 一段时间后再开启图 片下载任务。譬如先画一个默认图片，然后在 0.5S 后开始下载本 cell 的图片。<br>(5) 即使下载 cell 图片是在子线程中进行，在绘制 cell 过程中，也不能开启过多的子线程。 最好只有一个下载图片的子线程在活动。否则也会影响 UITableViewCell 的绘制，因而影响了 UITableViewCell 的滑动速度。(建议结合使用 NSOpeartion 和 NSOperationQueue 来下载图片， 如果想尽可能找的下载图片，可以把[self.queuesetMaxConcurrentOperationCount:4];)<br>(6) 最好自己写一个 cache，用来缓存 UITableView 中的 UITableViewCell，这样在整个 UITableView 的生命周期里，一个 cell 只需绘制一次，并且如果发生内存不足，也可以有效的 释放掉缓存的 cell。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jenkins持续构建-采坑大全-Mac版</title>
      <link href="/2018/05/30/Jenkins/"/>
      <content type="html"><![CDATA[<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。(百度百科🤦‍♀️)</p><h3 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p><a href="https://jenkins.io/download/" target="_blank" rel="noopener">Jenkins官网下载</a></p><ol><li><p>选择相对应的环境下载<br> <img src="/2018/05/30/Jenkins/jenkins.png" alt="Jenkins官网"></p></li><li><p>打开下载好的.pkg文件、狂点下一步即可<br>安装完成后系统会默认生成一个<a href="#">Jenkins用户</a>，Jenkins账户密码可在 <a href="#">系统偏好设置-用户    与群组-其他用户-管理员-更改密码</a> 重新设置<br> <img src="/2018/05/30/Jenkins/1.png" alt="安装步骤"></p></li><li><p>安装完成后会自动打开浏览器、如未打开可手动打开浏览器输入<a href="http://localhost:8080/login?from=%2F" target="_blank" rel="noopener">http://localhost:8080/login?from=%2F</a><br> <img src="/2018/05/30/Jenkins/2.png" alt="安装成功"></p></li><li><p>点击Finder: 按红字提示路径无法打开Finder,是因为secrets访问权限问题。按红色框提示输入电脑密码解锁修改文件夹权限和initialAdminPassword文件权限即可访问<br><code>$ command+shift+G: /Users/Shared/Jenkins/Home/</code><br> <img src="/2018/05/30/Jenkins/3.png" alt="管理员密码"></p></li><li><p>复制initialAdminPassword内密码到输入框点继续进行下一步<br> <img src="/2018/05/30/Jenkins/4.png" alt="解锁Jenkins"></p></li><li><p>此处是个bug。提示Jenkins实例离线、无法获取插件。【不要跳过插件安装】  如正常请看第9步骤<br> <img src="/2018/05/30/Jenkins/5.png" alt="Jenkins实例离线"></p></li><li><p>新打开一个tab页，输入网址<a href="http://localhost:8080/pluginManager/advanced" target="_blank" rel="noopener">http://localhost:8080/pluginManager/advanced</a>,最下面有个【升级站点】，把其中的链接改成<a href="http://updates.jenkins.io/update-center.json" target="_blank" rel="noopener">http://updates.jenkins.io/update-center.json</a>就好了。<br> <img src="/2018/05/30/Jenkins/6.png" alt="Jenkins实例离线"></p></li><li><p>更换完成后点击立即获取。如获取成功则会提示 xx秒之前获取了更新信息。<br> <img src="/2018/05/30/Jenkins/7.png" alt="Jenkins实例离线"></p></li><li><p>此时刷新Jenkins页面还是会提示离线，打开【活动监视器】搜索java，然后强制退出。关闭java服务后再刷新页面就显示正常了。<br> <img src="/2018/05/30/Jenkins/8.png" alt="Jenkins实例离线"></p></li><li><p>此时为正常显示页面，按需求选择安装推荐或自定义安装即可<br> <img src="/2018/05/30/Jenkins/9.png" alt="Jenkins实例离线"></p></li><li><p>安装完成后创建一个管理员用户<br><img src="/2018/05/30/Jenkins/10.png" alt="Jenkins实例离线"></p></li><li><p>创建完成后点击下一步，进入Jenkins。此时Jenkins已安装完成。<br><img src="/2018/05/30/Jenkins/11.png" alt="Jenkins实例离线"></p></li></ol>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续构建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个非常简洁好用的UIbutton扩展,快速设置button的image位置</title>
      <link href="/2018/04/18/UIButton-Category/"/>
      <content type="html"><![CDATA[<h4 id="转自tbl00c开源的一个基础组件库GitHub"><a href="#转自tbl00c开源的一个基础组件库GitHub" class="headerlink" title="转自tbl00c开源的一个基础组件库GitHub"></a>转自tbl00c开源的一个基础组件库<a href="https://github.com/tbl00c/TLKit.git" target="_blank" rel="noopener">GitHub</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">UIButton+Extensions.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, TLButtonImagePosition) &#123;</span><br><span class="line">    TLButtonImagePositionLeft = 0,              //图片在左，文字在右，默认</span><br><span class="line">    TLButtonImagePositionRight = 1,             //图片在右，文字在左</span><br><span class="line">    TLButtonImagePositionTop = 2,               //图片在上，文字在下</span><br><span class="line">    TLButtonImagePositionBottom = 3,            //图片在下，文字在上</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface UIButton (Extensions)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  image和title图文混排</span><br><span class="line"> *</span><br><span class="line"> *  @param  position    图片的位置，默认left</span><br><span class="line"> *  @param  spacing     图片和标题的间隔</span><br><span class="line"> *</span><br><span class="line"> *  @return     返回button最小的size</span><br><span class="line"> *</span><br><span class="line"> *  注意，需要先设置好image、title、font。网络图片需要下载完成后再调用此方法，或设置同大小的placeholder</span><br><span class="line"> */</span><br><span class="line">- (CGSize)setButtonImagePosition:(TLButtonImagePosition)position spacing:(CGFloat)spacing;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">UIButton+Extensions.m</span><br><span class="line"></span><br><span class="line">@implementation UIButton (Extensions)</span><br><span class="line"></span><br><span class="line">- (CGSize)setButtonImagePosition:(TLButtonImagePosition)position spacing:(CGFloat)spacing</span><br><span class="line">&#123;</span><br><span class="line">    CGSize imageSize = self.imageView.image.size;</span><br><span class="line">    CGSize titleSize = [self.titleLabel.text sizeWithAttributes:@&#123;NSFontAttributeName : self.titleLabel.font&#125;];</span><br><span class="line">    </span><br><span class="line">    CGSize buttonSize = CGSizeZero;</span><br><span class="line">    if (position == TLButtonImagePositionLeft || position == TLButtonImagePositionRight) &#123;</span><br><span class="line">        if (position == TLButtonImagePositionLeft) &#123;</span><br><span class="line">            self.imageEdgeInsets = UIEdgeInsetsMake(0, -spacing/2, 0, spacing/2);</span><br><span class="line">            self.titleEdgeInsets = UIEdgeInsetsMake(0, spacing/2, 0, -spacing/2);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            self.imageEdgeInsets = UIEdgeInsetsMake(0, titleSize.width + spacing/2, 0, -(titleSize.width + spacing/2));</span><br><span class="line">            self.titleEdgeInsets = UIEdgeInsetsMake(0, -(imageSize.height + spacing/2), 0, imageSize.height + spacing/2);</span><br><span class="line">        &#125;</span><br><span class="line">        buttonSize.width = imageSize.width + titleSize.width + spacing;</span><br><span class="line">        buttonSize.height = MAX(imageSize.height, titleSize.height);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        CGFloat imageOffsetX = titleSize.width &gt; imageSize.width ? (titleSize.width - imageSize.width) / 2.0 : 0;</span><br><span class="line">        CGFloat imageOffsetY = imageSize.height / 2;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        CGFloat titleOffsetXR = titleSize.width &gt; imageSize.width ? 0 : (imageSize.width - titleSize.width) / 2.0;</span><br><span class="line">        CGFloat titleOffsetX = imageSize.width + titleOffsetXR;</span><br><span class="line">        CGFloat titleOffsetY = titleSize.height / 2;</span><br><span class="line">        </span><br><span class="line">        if (position == TLButtonImagePositionTop) &#123;</span><br><span class="line">            self.imageEdgeInsets = UIEdgeInsetsMake(-imageOffsetY, imageOffsetX, imageOffsetY, -imageOffsetX);</span><br><span class="line">            self.titleEdgeInsets = UIEdgeInsetsMake(titleOffsetY, -titleOffsetX, -titleOffsetY, -titleOffsetXR);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            self.imageEdgeInsets = UIEdgeInsetsMake(imageOffsetY, imageOffsetX, -imageOffsetY, -imageOffsetX);</span><br><span class="line">            self.titleEdgeInsets = UIEdgeInsetsMake(-titleOffsetY, -titleOffsetX, titleOffsetY, -titleOffsetXR);</span><br><span class="line">        &#125;</span><br><span class="line">        buttonSize.width = MAX(imageSize.width, titleSize.width);</span><br><span class="line">        buttonSize.height = imageSize.height + titleSize.height + spacing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return buttonSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS常见面试题</title>
      <link href="/2018/04/16/Interview/"/>
      <content type="html"><![CDATA[<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ol><li><p>说一下内存管理中你经常用的几个修饰符<br>assign “设置方法” 只会执行针对“纯量”的简单赋值操作。<br>strong  此特质表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。<br>weak 此特质表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指的对象遭到推毁时，属性值也会清空。assigin 可以用非OC对象,而weak必须用于OC对象。在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理。自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。<br>unsafe_unretained  此特质的语义和assign相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”，当目标对象遭到推毁时，属性值不会自动清空，这一点与weak有区别。<br>copy 此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是设置方法并不保留新值，而是将其“拷贝”。当属性类型为NSString*时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”，就应该在设置新属性值时拷贝一份。<br>NSString、NSArray、NSDictionary可变类型常用copy，block也常用copy</p></li><li><p>Nsstring用copy的原因是什么？<br>这主要是为了防止NSString被修改。NSMutableString是NSStrig的子类，当NSString的赋值来源也是NSString时，strong和copy的作用相同，都是给复制来源的引用计数加1，当NSStrig的赋值来源是NSMutableString时，copy会做深拷贝，即重新生成一个新的对象，修改赋值来源不会影响NSString的值。<br>举个例子：A-&gt;B  A中的一个MutableString给B中的一个Property(NSString类型)赋值   首先是能接受的，父类可以接受子类，如果是strong，仅仅是生成一个指针，计数器加一，然后指向那个MutableString。如果NSString改变，B中那个跟着改变，因为是同一块内存区域。而选择Copy相当于又生成了一个NSString，与A中的MutableString独立。</p></li><li><p>Block为什么使用copy修饰?<br>默认情况下，block是存档在栈中，可能被随时回收，通过copy操作可以使其在堆中保留一份, 相当于一直强引用着, 防止出现内存泄露的情况。当block中需要用到self时或者说需要弱引用的时候，通过<strong>weak或者</strong>unsafe_unretained. 但是当需要强化的时候，比如说，在block中有延迟执行的操作的时候就必须将其弱化，需要用__strong来修饰就可以了。</p></li><li><p>**ARC中是怎么实现自动释放的?<br>这个时候我说的是，系统自动释放，但是会追加被问到系统是怎么释放的，我说是没有引用计数就自动释放了，但是会问到，系统是怎么知道引用计数为零需要释放了，这个才是问题的关键，这个时候应该回答说，这是被runloop控制的，每个任务都有自己的线程来完成，而每个线程都有自己对于的runloop，当一个任务结束的时候，就是runloop循环结束的时候会访问引用计数，就是还有没有被访问着，如果没有的话，就说明是零了，就会告诉系统为零需要释放，然后就会放到自动释放池中等待在一定的时间一起释放掉这些对象。</p></li></ol><h4 id="KVO-KVC"><a href="#KVO-KVC" class="headerlink" title="KVO-KVC"></a>KVO-KVC</h4><ol><li><p>简述KVO的实现原理（不要简单的说出文字原理，方法名一定要说）<br>kvo是基于runtime机制实现的，是通过监听属性来做相应的操作<br>当某个类的对象第一次被观察时，系统会在其运行期间动态的创建一个子类，在这个子类中重写基类中任何被观察属性的setter方法，在set方法中通知监听observe。<br>即通过调用<code>[self willchangeValueForKey:“key”];</code><br>和<code>[self didChangeValueForKey:“key”];</code>这两个方法会主动调用监听者内部的<br><code>-（void）observeValueForKeyPath</code>这个方法，从而实现监听。</p></li><li><p>简述KVC的实现原理<br>Kvc是间接通过字符串类型的key获取对应的属性值.<br>KVC的优点<br>可以访问私有属性<br>间接修改私有属性<br>可以访问id类型任何类型的属性值</p></li><li><p>valueForKey和valueForKeyPath的区别<br>keyPath包含了key的功能<br>valueForKeyPath可以访问对象的对象，但是valueForKey不可以，只能访问当前对象的属性<br>keyPath可以计算数组的长度</p></li></ol><h4 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h4><ol><li><p>Block为什么使用copy修饰<br>默认情况下，block是存放在栈中，可能被随时回收，通过copy操作可以使其在堆中保留一份, 相当于一直强引用着, 防止出现内存泄露的情况。<br>当block中需要用到self时或者说需要弱引用的时候，通过<strong>weak或者</strong>unsafe_unretained. 但是当需要强化的时候，比如说，在block中有延迟执行的操作的时候就必须将其弱化，需要用__strong来修饰就可以了</p></li><li><p>如果block体外面定义个一个int类型的a=10，在block体里面修改a = 20，此时a是多少，为什么，应该怎么做<br>a是10，因为局部变量修饰的值，在block体里面取得是值，而不是地址，在后面无论怎么修改都是取到新的值，应该用__block来修饰，这样就是取地址了。（还有的面试官会问，假如在block体外面用static修饰的话或者是在头文件中定义这个a呢，这个时候记住一点，除了局部修饰的block外面的值是取值，别的都是取址都是可以发生改变的）</p></li><li><p>在block中有一个用GCD修饰的线程，需要延时加载，这个时候会不会有什么问题，该怎么操作。<br>会可能出现野指针，也就是对象被提前释放了，是为了避免在 block 的执行过程中，突然出现 self 被释放的尴尬情况。通常情况下，如果不这么做的话，还是很容易出现一些奇怪的逻辑，甚至闪退.<br>防止这个，需要用到__strong来强引用一下。在延迟之后需要用到的时候不会被释放掉。</p></li></ol><h4 id="第三方框架和原理"><a href="#第三方框架和原理" class="headerlink" title="第三方框架和原理"></a>第三方框架和原理</h4><ol><li>简述SDWebImage的实现原理（这个时候不要只是答文字，重要api需要说出来）<br>1) 入口 <code>setImageWithURL:placeholderImage:options:</code> 会先把 placeholderImage 显示，<br>然后 SDWebImageManager 根据 URL 开始处理图片。<br>2) 进入 <code>SDWebImageManager-downloadWithURL:delegate:options:userInfo:</code>，交给 SDImageCache 从缓存查找图片是否已经下载 <code>queryDiskCacheForKey:delegate:userInfo:</code><br>3) 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调<br><code>imageCache:didFindImage:forKey:userInfo:</code> 到 SDWebImageManager。<br>4) SDWebImageManagerDelegate 回调 <code>webImageManager:didFinishWithImage:</code> 到 UIImageView+WebCache 等前端展示图片。<br>5) 如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。<br>6) 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。<br>7) 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。<br>8) SDImageCacheDelegate 回调 <code>imageCache:didFindImage:forKey:userInfo:</code>。进而回调展示图片。<br>9) 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片, 回调 <code>imageCache:didNotFindImageForKey:userInfo:</code>。<br>10) 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。<br>11) 图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<br>12) <code>connection:didReceiveData:</code> 中利用 ImageIO 做了按图片下载进度加载效果。<br>13) <code>connectionDidFinishLoading:</code> 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<br>14) 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br>15) 在主线程 <code>notifyDelegateOnMainThreadWithInfo:</code> 宣告解码完成，<br><code>imageDecoder:didFinishDecodingImage:userInfo:</code> 回调给 SDWebImageDownloader。<br><code>imageDownloader:didFinishWithImage:</code> 回调给 SDWebImageManager 告知图片下载完成。<br>16) 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<br>17) 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。</li><li>SDWebImage内部可以自己清理缓存吗？<br>SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片</li><li>SDWebImage怎么预先下载图片，方便后续使用?<br>提供了SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</li></ol><h4 id="下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）"><a href="#下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）" class="headerlink" title="下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）"></a>下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）</h4><p>大部分的下拉刷新控件，都是用contentInset实现的。默认情况下，如果一个UIScrollView的左上角在导航栏的正下方，那么它的contentInset是64，而contentOffset是-64。继续下拉的话，contentOffset就会越来越小，如果上滑，contentOffset就会增大，直到左上角达到屏幕的左上角时，contentOffset刚好为0<br>默认情况下，如果下拉一个UIScrollView，在松手之后，会弹回初始的位置（导航栏下方）。而大部分的下拉刷新控件，都是将自己放在UIScrollView的上方，起始y设置成负数，所以平时不会显示出来，只有下拉的时候才会出现，放开又会弹回去。然后在loading的时候，临时把contentInset增大，相当于把UIScrollView往下挤，于是下拉刷新的控件就会显示出来，然后刷新完成之后，再把contentInset改回原来的值，实现回弹的效果</p><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><ol><li>为什么应用存在沙盒中<br>iOS本地化存储的数据保存在沙盒中 ，每个应用的沙盒是独立，结构是相同的，这样比较安全（我没回答上来，面试官给说的答案，不知道正确性）</li><li>存储方式<br>1）Plist存储：Plist文件的Type可以是字典NSDictionary或数组NSArray，也就是说可以把字典或数组直接写入到文件中。<br>NSString、NSData、NSNumber等类型，也可以使用<code>writeToFile:atomically:</code>方法直接将对象写入文件中，只是Type为空。<br>2）NSUserDefaults，一般的登录注册的数据保存这个里面<br>3）NSKeyedArchiver归档 / NSKeyedUnarchiver解档<br>4) 归档和解档会在写入、读出数据之前进行序列化、反序列化，数据的安全性相对高一些。<br>&emsp;&emsp;1&gt; 对单个简单对象进行归档/解档，当然，也可以存储NSArray，NSDictionary等对象。<br>&emsp;&emsp;2&gt; 对多个对象进行归档/解档<br>&emsp;&emsp;3&gt; 归档保存自定义对象。定义一个Person类，如果想对person进行归档解档，首先要让Person遵守<nscoding>协议。<br>4）SQLite3<br>&emsp;&emsp;1&gt; 首先需要添加库文件libsqlite3.0.tbd<br>&emsp;&emsp;2&gt; 导入头文件#import &lt;sqlite3.h&gt;<br>&emsp;&emsp;3&gt; 打开数据库<br>&emsp;&emsp;4&gt; 创建表<br>&emsp;&emsp;5&gt; 对数据表进行增删改查操作<br>&emsp;&emsp;6&gt; 关闭数据库</nscoding></li><li>FMDB和CoraData的区别<br>FMDB是oc方式来封装c语言的sqlite，还是需要编写sqlite语句，<br>CoreData是oc方式来封装c语言的sqlite，不用编写任何sqlite语句，自动根据对象类型和属性名生成对应的sqlite语句<br>这两个的区别：CoreData不用编写sqlite语句，CoreData是不可控的，以为自动生成，会有很多不必要的属性，FMDB可以自己控制。</li><li>用sql语句怎么增加或者删除一个字段<br>1）增加表字段：<code>ALTER TABLE 表名 ADD COLUMN</code>字段名字段类型<br>2）删除表字段：<code>ALTER TABLE 表名 DROP COLUMN</code>字段名 字段类型<br>3）x修改表字段：<code>ALTER TABLE 表名 RENAME COLUMN</code>旧字段名 to 新字段名</li><li>沙盒中存储文件都包括什么，都是怎么存放的（有一个问了这个问题）<br>1)Application :存放程序源文件，上架前经过数字签名，上架后不可修改<br>2）Document：常用目录，iCloud备份目录，存放数据，这里不能缓存文件，否则上架不被通过<br>3）Library：<br>&emsp;&emsp;1&gt; Caches:存放 体积大又不需要备份的数据，SDWebImage缓存路径就是这个<br>&emsp;&emsp;2&gt; Preference:设置目录，iCloud会备份设置信息<br>4）tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能</li></ol><h4 id="Runloop（这个具体没什么问题，看文档吧）"><a href="#Runloop（这个具体没什么问题，看文档吧）" class="headerlink" title="Runloop（这个具体没什么问题，看文档吧）"></a>Runloop（这个具体没什么问题，看文档吧）</h4><ol><li>定义<br>RunLoop的实质是一个死循环，用于保证程序的持续运行，只有当程序退出的时候才会结束（由main函数开启主线程的RunLoop）</li><li>作用<br>保持程序的持续运行<br>处理App中的各种事件（触摸、定时器、Selector事件）<br>节省CPU资源，提高程序性能（该做事做事，没事做休息）<br>使用NSRunLoop（面向对象）或者CFRunLoopRef（底层C语言）</li><li>RunLoop的原理<br>RunLoop开启一个循环事件，并接受输入事件，接受的事件来自两种不同的来源：<br>输入源（input source）(传递异步事件)<br>定时源（timer source）(传递同步事件)<br>RunLoop接收到消息后采用handlePort、customSrc、mySelector和timerFired四个方法处理对应的事件<br>当RunLoop没有接收到消息时，则进入休眠状态，以保持程序持续运行</li></ol><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ol><li>NSOperation和GCD的区别<br>1）GCD是基于c的底层api，NSOperation属于object-c类。ios首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。<br>2）GCD优点：GCD主要与block结合使用。代码简洁高效。执行效率稍微高点。<br>3）NSOperation相对于GCD：<br>&emsp;&emsp;1&gt;，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在GCD基础上实现的，只不过是GCD更高一层的抽象。<br>&emsp;&emsp;2&gt;，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。<br>&emsp;&emsp;3&gt;NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）<br>&emsp;&emsp;4&gt;GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。<br>4)使用NSOperation的情况：各个操作之间有依赖关系、操作需要取消暂停、并发管理、控制操作之间优先级，限制同时能执行的线程数量.让线程在某时刻停止/继续等。<br>5)使用GCD的情况：一般的需求很简单的多线程操作，用GCD都可以了，简单高效。</li></ol><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ol><li><p>单例（这个需要会写，两种写法，好几次让手写<br>1）写法一：//提供一个static修饰的全局变量，强引用着已经实例化的单例对象实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static FileManager* sharedInstance = nil;</span><br><span class="line">//类方法，返回一个单例对象</span><br><span class="line">+(FileManager*) sharedInstance&#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (sharedInstance == nil) &#123;</span><br><span class="line">            sharedInstance = [[self alloc] init]; //注意：这里建议使用self,而不是直接使用类名Tools（考虑继承）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">//保证永远只分配一次存储空间</span><br><span class="line">+(id)allocWithZone:(NSZone *)zone&#123;</span><br><span class="line">    //使用加锁的方式，保证只分配一次存储空间</span><br><span class="line">    @synchronized(self)&#123;</span><br><span class="line">        if(sharedInstance == nil)&#123;</span><br><span class="line">            sharedInstance = [super allocWithZone:zone];</span><br><span class="line">            return sharedInstance;  // assignment and return on first allocation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil; //on subsequent allocation attempts return nil</span><br><span class="line">&#125;</span><br><span class="line">//让代码更加的严谨</span><br><span class="line">-(id)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2）写法二用GCD</span><br><span class="line">static SwitchMenuViewModel * segTitles = nil;</span><br><span class="line">+(instancetype)sharedSegTitles</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    dispatch_once(&amp;once,^&#123;</span><br><span class="line">        segTitles = [[SwitchMenuViewModel alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return segTitles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通知<br>NSNotification 是iOS中一个调度消息通知的类,采用单例模式设计,在程序中实现传值、回调等地方应用很广。在iOS中，NSNotification &amp; NSNotificationCenter是使用观察者模式来实现的用于跨层传递消息。<br>对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变，也不知道对象是什么<br>&emsp;&emsp;1&gt; 向观察者中心添加观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    [self addNotifications];//添加通知</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)addNotifications&#123;</span><br><span class="line">    //退出企业</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:NT_Exit_Company object:nil];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(ExitCompany:) name:NT_Exit_Company object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移除通知</span><br><span class="line">-(void)viewWillDisappear:(BOOL)animated  &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    [self removeNotifications];//添加通知</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)removeNotifications</span><br><span class="line">&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter]removeObserver:self name:NT_Exit_Company object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;2&gt; 通知中心向观察者发送消息</span><br><span class="line">[[NSNotificationCenter  defaultCenter] postNotificationName:NT_Exit_Company object:dict];</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;3&gt;实现通知之后的操作</span><br><span class="line">// 收到推送之后刷新界面</span><br><span class="line">-(void)RefreashHomeVC:(NSNotification *) obj</span><br><span class="line">&#123;</span><br><span class="line">    lable = obj.object;</span><br><span class="line">    [self ToDetectNetWork];//重新加载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>runtime是一套底层的C语言API，是一个实现Objective-C语言的C库。它是一门编译型语言、也是一门动态型的语言（这里强调下OC是静态类型语言），OC之所以能够做到即是编译型语言，又能做到动态语言，就是得益于runtime的机制。所谓runtime机制就是在C语言里边的函数调用到了OC里边就变成了另外一个名字，称之为消息发送。即objc_msgSend，这就是利用了runtime的消息机制特性，完成了一个动态调用的过程。还有一个重要的作用，可以交换两个方法的实现，代码是：method_exchangeImplementations</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ol><li>用ARC管理内存</li><li>在正确的地方使用 reuseIdentifier</li><li>尽量把views设置为透明</li><li>避免过于庞大的XIB</li><li>不要阻塞主线程</li><li>在Image Views中调整图片大小</li><li>选择正确的使用Collection</li><li>重用和延迟加载(lazy load) Views</li><li>避免日期格式转换</li><li>渲染方法</li><li>处理内存警告</li><li>避免反复处理数据</li><li>选择正确的数据格式</li><li>正确设定背景图片</li><li>减少使用Web特性</li><li>优化Table View</li><li>使用Autorelease Pool</li><li>选择是否缓存图片</li></ol><h4 id="NSTimer-（这个被问的多）"><a href="#NSTimer-（这个被问的多）" class="headerlink" title="NSTimer （这个被问的多）"></a>NSTimer （这个被问的多）</h4><ol><li>Nstimer计时一定是安全的吗，不安全怎么办<br>答案是否定的，而且有时候你会发现实际的触发时间跟你想象的差距还比较大。NSTimer不是一个实时系统，因此不管是一次性的还是周期性的timer的实际触发事件的时间可能都会跟我们预想的会有出入。差距的大小跟当前我们程序的执行情况有关系，比如可能程序是多线程的，而你的timer只是添加在某一个线程的runloop的某一种指定的runloopmode中，由于多线程通常都是分时执行的，而且每次执行的mode也可能随着实际情况发生变化。<br>假设你添加了一个timer指定2秒后触发某一个事件，但是签好那个时候当前线程在执行一个连续运算(例如大数据块的处理等)，这个时候timer就会延迟到该连续运算执行完以后才会执行。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会和后面的触发进行合并，即在一个周期内只会触发一次。但是不管该timer的触发时间延迟的有多离谱，他后面的timer的触发时间总是倍数于第一次添加timer的间隙</li><li>nstimer在使用的时候，应该注意什么<br>1）必须得把timer添加到runloop中，它才会生效<br>2）要让timer生效，必须保证该线程的runloop已启动，而且其运行的runloopmode也要匹配<br>3）划动下面的tableview没有变化，是为什么？<strong><em>**</em></strong>经常被问到这个问题<br>在tableview滑动时timer就是显示暂停，原因是timer的这个简便构造方法把timer加入了NSRunLoopDefaultMode上，而tableview在滑动时只会处理UITrackingRunLoopMode，RunLoop并没有处理timer事件。<br>解决的办法是将timer绑定到NSRunLoopCommonModes上，通过以下方法构造timer：nstimer在使用的时候，应该注意什么</li></ol><h4 id="延伸问题"><a href="#延伸问题" class="headerlink" title="延伸问题:"></a>延伸问题:</h4><ol><li><p>什么是死锁，举例说明<br>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住<br>比如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(_queue, ^&#123;</span><br><span class="line">    &amp;emsp;dispatch_sync(_queue, ^&#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>frame和bounds的区别<br>frame是指的该view在父view坐标系统中的位置和大小<br>bounds是该view在本身坐标系统中的位置和大小</p></li><li><p>什么是三次握手（笔试）<br>第一次握手：建立连接时，客户端发送同步序列编号到服务器，并进入发送状态，等待服务器确认<br>第二次握手：服务器收到同步序列编号，确认并同时自己也发送一个同步序列编号，+确认标志，此时服务器进入接受状态<br>第三次握手：客户端收到服务器发送的包，并向服务器发送确认标志，随后链接成功。</p></li><li><p>有a b c d 四个异步请求，如何在a b  c 都完成之后去执行d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1) 创建队列</span><br><span class="line">queue dispatch_queue_t  queue = (dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0))</span><br><span class="line">2) 创建组</span><br><span class="line">group dispatch_group_t group = dispatch_group_creat();</span><br><span class="line">3) 将queue和group加入到执行的任务中 并执行a  b  c</span><br><span class="line">dispatch_group_async(group,queue,^&#123;//任务a&#125;)</span><br><span class="line">dispatch_group_async(group,queue,^&#123;//任务b&#125;)</span><br><span class="line">dispatch_group_async(group,queue,^&#123;//任务c&#125;)</span><br><span class="line">4) 完了之后引用</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue()),^&#123;</span><br><span class="line">    //执行d操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="UIView-和-CALayer的区别"><a href="#UIView-和-CALayer的区别" class="headerlink" title="UIView 和 CALayer的区别"></a>UIView 和 CALayer的区别</h4><ol><li>UIView集成UIResponder，因此UIView可以处理响应时间，而CALayer集成NSObject，所以它只负责内容的创建、绘制。</li><li>UIView负责对内容的管理，而CALayer则是对内容的绘制。</li><li>UIView中的位置属性只有frame、bounds、center，而CALyaer除了具备这些属性之外还有anchorPoint、position。</li><li>通过修改CALayer可以实现UIView无法实现的很多高级功能。             </li></ol>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发常见bug</title>
      <link href="/2018/03/26/question/"/>
      <content type="html"><![CDATA[<h4 id="使用第三方框架Alamofire、Kingfisher-等等时报错dyld-Library-not-loaded-Reason-image-not-found"><a href="#使用第三方框架Alamofire、Kingfisher-等等时报错dyld-Library-not-loaded-Reason-image-not-found" class="headerlink" title="使用第三方框架Alamofire、Kingfisher 等等时报错dyld: Library not loaded Reason: image not found"></a>使用第三方框架Alamofire、Kingfisher 等等时报错dyld: Library not loaded Reason: image not found</h4><ol><li>在Xcode中的Build Phases中的Copy Files项中，将你要引用的framework拖到“Linked Frameworks and Libraries“中</li><li>把Build Phases 里Social.framework后边的选项修改成为Optional就可以了<br><img src="/2018/03/26/question/q1.png" alt="如图"></li></ol><h4 id="Swift4-0-中使用KVC给model赋值时无法赋值"><a href="#Swift4-0-中使用KVC给model赋值时无法赋值" class="headerlink" title="Swift4.0 中使用KVC给model赋值时无法赋值"></a>Swift4.0 中使用KVC给model赋值时无法赋值</h4><ol><li>在model中给属性前添加@objc关键字</li></ol><h4 id="在iOS-11上给navigationBar的titleView添加searchBar导致navigationBar高度增高"><a href="#在iOS-11上给navigationBar的titleView添加searchBar导致navigationBar高度增高" class="headerlink" title="在iOS 11上给navigationBar的titleView添加searchBar导致navigationBar高度增高"></a>在iOS 11上给navigationBar的titleView添加searchBar导致navigationBar高度增高</h4><ol><li>自定义一个view，然后将searchBar添加到自定义view上，再将自定义view赋值给titleView<br><img src="/2018/03/26/question/q2.png" alt="如图"></li></ol><h4 id="UISearchBar进入编辑状态时向上偏移"><a href="#UISearchBar进入编辑状态时向上偏移" class="headerlink" title="UISearchBar进入编辑状态时向上偏移"></a>UISearchBar进入编辑状态时向上偏移</h4><p><code>设置searchController.hidesNavigationBarDuringPresentation = NO;</code></p><h4 id="UISearchController取消遮盖蒙版"><a href="#UISearchController取消遮盖蒙版" class="headerlink" title="UISearchController取消遮盖蒙版"></a>UISearchController取消遮盖蒙版</h4><p><code>设置searchController.dimsBackgroundDuringPresentation = NO;</code></p><h4 id="如何监听UISearchController遮盖点击事件"><a href="#如何监听UISearchController遮盖点击事件" class="headerlink" title="如何监听UISearchController遮盖点击事件"></a>如何监听UISearchController遮盖点击事件</h4><p>点击遮盖时就是将searchController隐藏、所以监听UISearchController消失的事件即可<br><code></code></p><ul><li>(void)willDismissSearchController:(UISearchController *)searchController<br>{<br>  // TODO:<br>}<code></code></li></ul><h4 id="解决tableView的sectionIndex和searchBar冲突问题"><a href="#解决tableView的sectionIndex和searchBar冲突问题" class="headerlink" title="解决tableView的sectionIndex和searchBar冲突问题"></a>解决tableView的sectionIndex和searchBar冲突问题</h4><p>把searchBar加在一个UIView上，然后把UIView加在tableHeaderView上，同时sectionIndex背景色要清除</p><p><code></code><br>UIView *headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kScreen_width, 56)];<br>[headerView addSubview:self.searchController.searchBar];<br>[self.tableView setTableHeaderView:headerView];</p><p>[self.tableView setSectionIndexBackgroundColor:[UIColor clearColor]];<br><code></code></p>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo+Coding.net/Github搭建自己的博客</title>
      <link href="/2018/03/02/SetBlog/"/>
      <content type="html"><![CDATA[<p>　　因为gitHub服务器在国外，而且gitHub不让百度的爬虫爬取内容，导致了搭建在gitHub上的博客访问速度非常慢，博客不会被百度搜索到。所以建议选择国内的Coding.net来搭建博客。搭建方法几乎是一致的。下面讲一下如何基于Coding.net搭建自己的博客。　　</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="初始化blog"><a href="#初始化blog" class="headerlink" title="初始化blog"></a>初始化blog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="启动预览blog"><a href="#启动预览blog" class="headerlink" title="启动预览blog"></a>启动预览blog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd blog</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><img src="/2018/03/02/SetBlog/server.png" alt="如图"><br>在浏览器输入：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 显示如下图就成功了<br><img src="/2018/03/02/SetBlog/Hexo.jpg" alt="如图"></p><h3 id="设置33种主题样式"><a href="#设置33种主题样式" class="headerlink" title="设置33种主题样式"></a><a href="https://segmentfault.com/a/1190000009544924#articleHeader2" target="_blank" rel="noopener">设置33种主题样式</a></h3><h3 id="搭建博客大全"><a href="#搭建博客大全" class="headerlink" title="搭建博客大全"></a><a href="http://cherryblog.site/" target="_blank" rel="noopener">搭建博客大全</a></h3>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/02/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记事 </tag>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/404.html"/>
      <content type="html"><![CDATA[<p>&lt;!DOCTYPE HTML&gt;</p><html><br><head><br>  <meta http-equiv="content-type" content="text/html;charset=utf-8;"><br>  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><br>  <meta name="robots" content="all"><br>  <meta name="robots" content="index,follow"><br></head><br><body><br><br><script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="http://ylxie.top/" homepagename="回到我的主页"></script><br><br></body><br></html>]]></content>
    </entry>
    
    <entry>
      <title>关于本站</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<p>博客宗旨: 把最实用的经验，分享给最需要的读者，希望每一位来访的朋友都能有所收获！</p>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/categories/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
