<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开发常见bug爬坑记录]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%B0%81%E8%A3%85Framework%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[常见问题爬坑记录 封装framework使用category时需要添加-ObjC/-all_load FMDB插入时使用‘%@’遇到”that’ girl”这种带有“’”符号会插入失败，建议使用?代替‘%@’ CocoaPods 私有库验证时需添加—sources=私有库地址 错误信息: - ERROR | [iOS] unknown: Encountered an unknown error (CocoaPods could not find compatible versions for pod “xxx”: (cocoaPods找不到库，因为没关联sources) 导入静态库报警告(清空deviceData前提) 在other linker flag 输入-ObjC 错误信息：note: Linking a static library that was built with -gmodules, but the module cache was not found. Redistributable static libraries should never be built with module debugging enabled. The debug experience will be degraded due to incomplete debug information. 解决方案 ：The ‘Pods-project name’ target has transitive dependencies that include static binaries1、把pod中的含有静态库的第三方库手动编译为动态库。较耗时复杂，后续更新维护应该还需要再次编译。编译的步骤2、将含有静态库的第三方库从pod中删除，然后手动拖到项目中。简单快速，但是有重命名风险，项目文件层级不够美观，无法获取该库的更新进程，后续更新也需要重新下载拖入。3、不做处理，不引入第三方swift库，swift中使用对应的oc第三方库。不是长久之计，不利于swift技术积累。4、使用Carthage。关于Carthage的介绍和使用方法。方便快捷，完美解决该问题。项目中可以使用两个不相互冲突的第三方库版本管理工具吗？我想是可以的！这样做看似会有问题，实则一点没有。用起来之后感觉不到Carthage的存在，没有任何不爽的感觉。 依赖三方静态库需添加pre_install do |installer| Pod::Installer::Xcode::TargetValidator.send(:define_method, :verify_no_static_framework_transitive_dependencies) {}end ld: 1 duplicate symbol forarchitecture x86_64clang:error: linker command failed with exit code 1 (use -v to see invocation) 1、文件重复 或者 在多个文件中重复定义某个东西2、导入第三方库造成的 #import “XXX.h” 写成了#import”XXX.m”3、找到Build settings-&gt;Linking-&gt;Other Linker Flags，将此属性修改成-all_load]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年面试题(基础)以及答案]]></title>
    <url>%2F2019%2F03%2F24%2F2019%E5%B9%B4%E9%9D%A2%E8%AF%95%E9%A2%98(%E5%9F%BA%E7%A1%80)%E4%BB%A5%E5%8F%8A%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[面向对象基础面试题 面向对象的几个设计原则？ 单一职责、开闭原则、里氏替换原则、依赖导致原则、接口隔离原则、迪米特原则(设计模式之禅第一部分) Hash表的实现？ 哈希表（hash table，也叫散列表），是根据键（key）直接访问访问在内存储存位置的数据结构。哈希表本质是一个数组，数组中的每一个元素成为一个箱子，箱子中存放的是键值对。根据下标index从数组中取value。关键是如何获取index，这就需要一个固定的函数（哈希函数），将key转换成index。不论哈希函数设计的如何完美，都可能出现不同的key经过hash处理后得到相同的hash值，这时候就需要处理哈希冲突。（拉链法和开放定址线性探测法） 什么是进程和线程？有什么区别？ 线程是轻型进程，是CPU独立运行和独立调度的基本单位； 进程是程序的一次执行，是资源分配的基本单位； 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。系统在运行时会为每个进程分配内存，而不会为线程分配。 内存的几大区域？各自的职能？（由高地址向低地址） 栈区：存放局部变量和函数的实参，编译器自动分配并释放。（速度快。不会产生内存碎片，可用空间小） 堆区：OC中使用new方法创建的对象，程序员手动申请并释放。（alloc分配的内存，速度慢，容易产生内存碎片。但是使用方便） 静态区（全局区）：用来存放没有初始化的全局变量和静态变量。（Xcode8中全局变量和静态变量都存在静态区/BSS断，不管是否初始化） 常量区（数据段）：用来存储已经初始化的全局变量，静态变量，常量数据，程序结束后由系统释放。（Xcode8存储常量） 代码区：代码的二进制文件/用来存储程序的代码指令。 架构、框架和设计模式的区别？ 架构：是一种已经提供了关系布局的骨架，它是由关系设计而来的，无论设计与使用的人，至少要了解它的作用，特别是关系。 框架：是一种工具(就是一些复用的代码)，它不是学问，基于设计模式的一种特定实现，它更多是面向程序员提供某些已经实现的功能，和有限度的关系管理。 设计模式：是一种对象关系管理与设计的学问，一种思想，它不属于任何一种语言。因此设计模式出现后，衡量一个程序员的水平，其中有一个领域就是对设计模式的了解程度。它代表了你归纳、组织等和代码与对象关系的设计能力。 谈一下你理解的MVC、MVVM、MVP和VIPER？ MVC：M(业务模型层)、V(展示层)、C(控制器层) 是由Controller驱动的，Controller持有View，并响应View上的交互事件，根据交互调用不同的Model方法取得反馈数据，再将数据传递给View展示。达到了代码复用、易拓展、可维护的效果，也产生了C层不易测试、业务逻辑和业务展示强耦合 MVP：是由View驱动的，View层持有一个对应的Presenter的引用，View上的交互事件首先会调用Presenter提供的接口，然后Presenter调用Model提供的方法取得数据，最后Presenter将取得的数据传递到View上展示。将业务逻辑与业务展示做了一层隔离，业务逻辑都转移到P层，减少了耦合，对比C层更容易测试。但也导致VP之间的数据交互太繁琐 MVVM：MVVM各层的职责和MVP的类似，VM对应P层，只是在MVVM的View层多了数据绑定的操作。创建了一个视图抽象。将业务逻辑和业务展示分离，方便测试并且逻辑结构清晰。但数据绑定使得 Bug 很难被调试。双向绑定也使类很难被重用。 VIPER：VIPER彻底弱化了VC的概念，让VC变成了真正意义上的View。把VC的职责进行了彻底的拆分，分散到各个子层里面了，做到了每个模块都可以单独测试和复用，但是也导致了代码过多、逻辑比较绕的问题。 iOS UI基础 UIView和CALayer的区别？（CALayer的逻辑树、动画树和显示树） UIView可以响应事件处理，CALayer不可以。UIView是CALayer的delegate UIView主要是对显示内容的管理，而CALayer主要侧重显示内容的绘制。 在做iOS动画的时候，修改非RootLayer的属性（位置、颜色等）会默认产生隐式动画，而修改UIView不会。 逻辑树：就是代码里可以操纵的，例如更改layer的属性等就在这里。 动画树：这是一个中间层，系统在这一层上更改属性，进行各种渲染操作。 显示树：就是当前正被显示在屏幕上的内容。 loadView是干嘛用的？ 每次访问UIViewController的view(self.view,controller.view)或者view为nil，loadView方法就会被调用。 loadView方法是用来创建UIViewController的View的 [super loadView]会去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view，如果没有找到xib文件，就会创建一个空白的UIView并赋值给UIViewController的view属性。 layoutIfNeeded、layoutSubviews和setNeedsLayout的区别？ layoutSubviews:调用addSubview、设置并改变视图的frame属性、滑动UIScrollView及继承UIScrollView的控件、旋转屏幕时都会触发layoutSubviews方法 layoutIfNeet:如果有需要刷新的标记，立即调用layoutSubviews进行布局。(如果没有标记不会调用layoutSubviews) setNeedsLayout:标记为需要重新布局，异步调用layoutIfNeed刷新布局，不立即刷新，在下一轮RunLoop结束前刷新，对于这一轮RunLoop之内的所有布局和UI上的更新指挥刷新一次，layoutSubviews一定会被调用。 iOS的响应链？什么情况会影响响应链？ 响应链是由一串UIResponder对象链接，当APP接收事件时，UIKit自动引导事件到最合适的响应者对象，也叫做第一响应者。事件由上往下传递，直到能响应事件为止。重写hitTest:withEvent会影响响应链。 运动事件相关的加速度计、陀螺仪、磁强计都不属于响应者链。而是由CoreMotion传递事件给你指定的对象。 说几种给UIImageView添加圆角的方式？ 通过设置UIView的layer来设置圆角 通过Graphics绘制图片，将图片裁剪成圆角 通过贝塞尔曲线绘制圆角 通过mask遮罩，在原图片上盖一张圆形图片 iOS中实现动画的方式有哪些？(详见iOS动画核心技术与案例) 显示层动画(UIView动画、CALayer关键帧、逐帧动画、Gif动画) 内容层动画(Core Animation系列动画、CAEmitterCell粒子动画等) 3D动画(CATransform3D动画、Cover Flow3D效果) 转场动画(CATransition动画) 使用drawRect有什么影响？ 在drawRect方法中创建一个新的对象，重复执行[self addSubView:view];会导致对象重复创建，引起视图错误，内存暴增。主动调用setNeedsDisplay也会调drawRect方法 绘制图形性能的优化最好的办法就是不去绘制。 利用专有图层代替绘图需求 必须用到绘图时尽量缩小视图面积。并尽量降低重绘频率。 异步绘制，计算内容，提前在其他线程绘制图片。在主线程中直接设置图片。 OC基础 我们说的Objective-C是动态运行时语言是什么意思？ OC的动态运行时是指OC具有动态类型、动态绑定和动态加载的特性。 动态类型：如id类型，运行时才确定对象的所属类。静态类型是强类型，动态类型是弱类型。 动态绑定：使程序直到运行时才确定调用对象的实际方法。 动态加载：让程序在运行时添加代码块及其他资源。用户可以根据需要执行一些可执行代码和资源，而不是在启动时就加载所有组件。 static和const的区别？ static:修饰局部变量只初始化一次，该变量在程序运行期间不释放。分配在静态存储区。 static:全局变量本身就是静态存储方式，以static修饰以后还是静态存储方式。区别在于非静态全局变量的作用域是整个源程序，而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效。在同一个源程序的其他文件中不能使用。 const:仅仅用来修饰右边的变量，被const修饰的变量是只读的。 为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别? 防止循环引用。(controller—&gt;tableView–&gt;delegate—&gt;controller) delegate偏重与用户交互的回调，dataSource侧重数据处理的回调。 block运行成本高，出栈需要将使用的数据从栈内存拷贝到堆内存，使用完或者block置为nil才销毁。delegate只是保存了一个对象指针，直接回调，没有额外消耗。 block的代码可读性更好，直接实现就好了。而delegate的实现比较麻烦，需要声明协议，声明代理，遵守协议，实现协议方法。 建议优先使用block，如果回调的状态很多，调用次数频繁。建议使用delegate。 block和delegate都各有优点。所以我们要理解区分使用场景。应用合适的回调方式。 属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？ 属性的实质@property = ivar + getter + setter; 利用class_copyPropertyList查看类的所有属性 利用class_copyIvarList查看类的所有成员变量 利用class_copyMethodList查看类的所有方法。 属性的默认关键字是什么？ automatic、readwrite、strong NSString为什么要用copy关键字，如果用strong会有什么问题？（注意：这里没有说用strong就一定不行。使用copy和strong是看情况而定的） copy修饰的是深拷贝，改变源字符串，不影响copy的属性内容。 strong修饰的属性就随着源字符串改变而改变了。 如何令自己所写的对象具有拷贝功能? 实现NSCoping协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying与 NSMutableCopying协议。 简述kvo、kvc、Delegate他们之间的区别？ 代理的效率比通知要高。 代理比通知更加直接。 kvo和通知，代理一样，都是负责通信的。kvo和通知没有返回值，而代理有返回值。 代理是一对一，通知，kvo是一对多。 include与#import的区别？#import与@class的区别？ include 是C预言中用来引用的关键字。 import 是OC中用来代替 include的关键字。#import确保了同一个文件只能被导入一次，从而别面了使用 #include容易引起的重复导入问题。 @class只是告诉编译器，后边遇到的这名称是类名，至于这个类是如何实现的暂时不考虑，用来解决线程锁死的问题。 nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？ nonatomic和atomic用来决定编译器生成的getter和setter操作是否为原子。 atomic不是绝对的线程安全。因为atomic的本意是指属性的存取方法是线程安全的，不是保证整个对象是线程安全的。在线程中操作对象加锁。 Objective-C与C、C+++之间的联系和区别？ OC与C的区别：OC中兼容C两者可以混合编程。OC是面向对象的，有类，对象的概念，C却木有。 C是面向过程的语言。 OC与C++的区别： 继承。OC不可以多重继承，C++却可以 函数调用。OC需要通过消息传递机制调用函数，C++却可以直接调用 定型。OC是动态定型。C++是等着你去找他。是静态类型。 接口。OC采用的是protocol协议。C++采用虚函数的形式。 方法重载。OC不允许有同一个类中出现两个相同的方法名。C++中允许两个方法名相同。 UICollectionView自定义layout如何实现？ 继承UICollectionViewLayout之后只需要重载几个提供布局核心特性的方法，其他方法只需按情况重载即可， 覆写prepareLayout方法，并在里面事先就计算好必要的布局信息并存储起来。 collectionViewContentSize方法基于初始计算，返回整体内容区域的size layoutAttributesForElementsInRect:方法返回指定区域中cells和views等布局属性 layoutAttributesForItemAtIndexPath设置itemSize的大小，cell之间的间距等。 进程和线程的区别？同步异步的区别？并行和并发的区别？ 进程：是资源的分配和调度的一个独立单元， 线程：是CPU调度的基本单元 同步：是顺序执行，执行完当前的任务再执行下一个，需要等待、协调运行。 异步：是彼此独立，多个任务之间不必要互相等待，只要CPU空闲，就可以同时执行多个任务，不需要等待其它任务的完成。 并发：指一个时间段中几个程序都处于已启动到运行完毕之间，且这几个程序都是在同一个处理机上运行。 并行：并行是针对多处理器而言的，指同时发生多个并发事件 线程间通信？ performSelectorOnMainThread:withObject:waitUntilDone performSelector:onThread:withObject:waitUntilDone CGD:dispatch_async异步执行任务再回到getmainqueue主线程 GCD的一些常用的函数？（group，barrier，信号量，线程同步） dispatch_sync同步 dispatch_async异步 dispatch_barrier_async栅栏 dispatch_after定时器 dispatch_once执行一次 dispatch_group、dispatch_group_notify dispatch_group_enter、dispatch_group_leave dispatch_semaphore(保持线程同步，将异步执行任务转换为同步执行任务/保证线程安全，为线程加锁) 如何访问并修改一个类的私有属性？ 通过KVC访问并修改。 通过runtime访问并修改。 数据持久化的几个方案？ plist文件、preference偏好设置、归档、SQLite3(fmdb)、CoreData、Realm 说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？ 从前台到后台:applicationWillResignActive、applicationDidEnterBackground 从后台到前台:applicationWillEnterForeground、applicationDidBecomeActive 第一次启动:application:didFinishLaunchingWithOptions、applicationDidBecomeActive 通过URLScheme打开App:applicationWillEnterForeground、application:openURL:sourceApplication:annotation、applicationDidBecomeActive NSCache优于NSDictionary的几点？ NSCache是线程安全的。 当内存不足时NSCach会自动释放内存。 NSCache可以指定缓存的限额，当缓存超出限额自动释放内存 知不知道Designated Initializer？使用它的时候有什么需要注意的问题？ 指定初始化方法，只能标识init命名的方法。 子类指定了新的初始化器，那么在这个初始化器内部必须调用父类的Designated Initializer。并且需要重写父类的Designated Initializer，将其指向子类新的初始化器。也可以用NS_UNAVAILABLE宏禁用父类的初始化器。 子类没有指定新的初始化器，也可以重写父类的Designated Initializer，但需要调用直接父类的Designated Initializer。 正确编写Designated Initializer的几个原则 实现description方法能取到什么效果？ 不实现会打印&lt;类名：内存地址&gt; 实现会打印description的描述信息 objc使用什么机制管理对象内存？(Objective-C高级编程 iOS与OS X多线程和内存管理) 自动引用计数 自己生成的对象自己持有（alloc/new/copy/mutableCopy…） 非自己生成的对象自己也能持有(retain) 不再需要自己持有的对象时释放(release) 非自己持有的对象无法释放(dealloc) 如何绘制UIView?绘制一个UIView最灵活的方法就是由它自己完成绘制。实际上你不是绘制一个UIView，而是子类化一个UIView并赋予绘制自己的能力。当一个UIView需要执行绘制操作时，drawRect：方法就会被调用，覆盖此方法让你获得绘图操作的机会。当drawRect：方法被调用，当前图形的上下文也被设置为属于视图的图形上下文，你可以使用Core Graphic或者UIKit提供的方法将图形画在该上下文中。 gcd产生死锁的原因及解锁的方法产生死锁的必要条件：1.互斥条件，2.请求与保持条件，3.不剥夺条件，4.循环等待条件。解决办法：采用异步执行block。 get请求与post请求的区别 get是向服务器发索取数据的一种请求，而post是向服务器提交数据的一种请求 get没有请求体，post有请求体 get请求的数据会暴露在地址栏中，而post请求不会，所以post请求的安全性比get请求号 get请求对url长度有限制，而post请求对url长度理论上是不会收限制的，但是实际上各个服务器会规定对post提交数据大小进行限制。 谈谈你对多线程开发的理解？ios中有几种实现多线程的方法？ 使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片，视频的下载； 发挥多核处理器的优势，并发执行让系统运行的更快，更流畅，用户体验更好； 大量的线程降低代码的可读性； 更多的线程需要更多的内存空间； 当多个线程对同一个资源出现争夺的时候要注意线程安全的问题。 ios有3种多线程编程的技术：1.NSThread，2.NSOperationQueue，3.gcd； XMPP工作原理；xmpp系统特点 工作原理： 所有从一个client到另一个client的jabber消息和数据都要通过xmpp server client链接到server server利用本地目录系统的证书对其认证 server查找，连接并进行相互认证 client间进行交互特点： 客户机/服务器通信模式； 分布式网络； 简单的客户端； XML的数据格式； 地图的定位是怎么实现的？ 导入了CoreLocation.framework ios8以后，如果需要使用定位功能，就需要请求用户授权，在首次运行时会弹框提示 通过本机自带的gps获取位置信息(即经纬度) 苹果内购实现流程 程序通过bundle存储的plist文件得到产品标识符的列表。 程序向App Store发送请求，得到产品的信息。 App Store返回产品信息。 程序把返回的产品信息显示给用户（App的store界面） 用户选择某个产品 程序向App Store发送支付请求 App Store处理支付请求并返回交易完成信息。 App获取信息并提供内容给用户。 支付宝，微信等相关类型的sdk的集成 在支付宝开发平台创建应用并获取APPID 配置密钥 集成并配置SDK 调用接口（如交易查询接口，交易退款接口） 生成二维码的步骤 使用CIFilter滤镜类生成二维码 对生成的二维码进行加工，使其更清晰 自定义二维码背景色、填充色 自定义定位角标 在二维码中心插入小图片 在使用XMPP的时候有没有什么困难 发送附件（图片，语音，文档…）时比较麻烦 XMPP框架没有提供发送附件的功能，需要自己实现 实现方法，把文件上传到文件服务器，上传成功后获取文件保存路径，再把附件的路径发送给好友 是否使用过环信，简单的说下环信的实现原理 环信是一个即时通讯的服务提供商 环信使用的是XMPP协议，它是再XMPP的基础上进行二次开发，对服务器Openfire和客户端进行功能模型的添加和客户端SDK的封装，环信的本质还是使用XMPP，基于Socket的网络通信 环信内部实现了数据缓存，会把聊天记录添加到数据库，把附件（如音频文件，图片文件）下载到本地，使程序员更多时间是花到用户体验体验上。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优化复杂tableView卡顿问题？]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%A4%8D%E6%9D%82tableView%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[导致tableView卡顿的原因： cellForRowAtIndexPath:方法中处理了过多业务 cell的subview层级太复杂，做了大量透明处理 cell的height动态变化时计算方式不对 优化tableView： cell的行高不是固定值，需要计算，则要尽可能缓存行高值，避免重复计算行高。因为 heightForRowAtIndexPath:是调用最频繁的方法。 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用!(SDWebImage 已经实现异 步加载，配合这条性能杠杠的)。 正确使用 reuseIdentifier 来重用 Cells 尽量少用或不用透明图层 如果 Cell 内现实的内容来自 web，使用异步加载，缓存请求结果 减少 subviews 的数量 在 heightForRowAtIndexPath:中尽量不使用 cellForRowAtIndexPath:，如果你需要用到它， 只用一次然后缓存结果 所有的子视图都预先创建，如果不需要显示可以设置 hidden，尽量少动态给 Cell 添加 View 颜色不要使用 alph 栅格化， cell 异步加载图片以及缓存 cell 的 subViews 的各级 opaque 值要设成 YES，尽量不要包含透明的子 Viewopaque 用于辅助绘图系统，表示 UIView 是否透明。在不透明的情况下，渲染视图时需要快速 地渲染，以􏰀高性能。渲染最慢的操作之一是混合(blending)。􏰀高性能的方法是减少混合操 作的次数，其实就是 GPU 的不合理使用，这是硬件来完成的(混合操作由 GPU 来执行，因为这 个硬件就是用来做混合操作的，当然不只是混合)。 优化混合操作的关键点是在平衡 CPU 和 GPU 的负载。还有就是 cell 的 layer 的 shouldRasterize 要设成 YES。 不要将 tableview 的背景颜色设置成一个图片。这回严重影响 UITableView 的滑动速度。在 限时免费搜索里，我曾经翻过一个错误:self.tableView_.backgroundColor = [UIColorcolorWithPatternImage:[UIImageimageNamed:@”background.png”]]; 通过这种方式 设置 UITableView 的背景颜色会严重影响 UTIableView 的滑动流畅性。修改成 self.tableView_.backgroundColor = [UIColor clearColor];之后，fps 从 43 上升到 60 左右。 滑动比较流畅。 异步绘制 (1) 在绘制字符串时，尽可能使用 drawAtPoint: withFont:，而不要使用更复杂的 drawAtPoint:(CGPoint)point forWidth:(CGFloat)width withFont:(UIFont *)font lineBreakMode:(UILineBreakMode)lineBreakMode; 如果要绘制过长的字符串，建议自己先截 断，然后使用 drawAtPoint: withFont:方法绘制。(2) 在绘制图片时，尽量使用 drawAtPoint，而不要使用 drawInRect。drawInRect 如果在绘 制过程中对图片进行放缩，会特别消耗 CPU。(3) 其实，最快的绘制就是你不要做任何绘制。有时通过 UIGraphicsBeginImageContextWithOptions() 或者 CGBitmapContextCeate() 创建位图会显 得更有意义，从位图上面抓取图像，并设置为 CALayer 的内容。如果你必须实现 -drawRect:，并且你必须绘制大量的东西，这将占用时间。(4) 如果绘制 cell 过程中，需要下载 cell 中的图片，建议在绘制 cell 一段时间后再开启图 片下载任务。譬如先画一个默认图片，然后在 0.5S 后开始下载本 cell 的图片。(5) 即使下载 cell 图片是在子线程中进行，在绘制 cell 过程中，也不能开启过多的子线程。 最好只有一个下载图片的子线程在活动。否则也会影响 UITableViewCell 的绘制，因而影响了 UITableViewCell 的滑动速度。(建议结合使用 NSOpeartion 和 NSOperationQueue 来下载图片， 如果想尽可能找的下载图片，可以把[self.queuesetMaxConcurrentOperationCount:4];)(6) 最好自己写一个 cache，用来缓存 UITableView 中的 UITableViewCell，这样在整个 UITableView 的生命周期里，一个 cell 只需绘制一次，并且如果发生内存不足，也可以有效的 释放掉缓存的 cell。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins持续构建-采坑大全-Mac版]]></title>
    <url>%2F2018%2F05%2F30%2FJenkins%2F</url>
    <content type="text"><![CDATA[Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。(百度百科🤦‍♀️) Jenkins安装Jenkins官网下载 选择相对应的环境下载 打开下载好的.pkg文件、狂点下一步即可安装完成后系统会默认生成一个Jenkins用户，Jenkins账户密码可在 系统偏好设置-用户 与群组-其他用户-管理员-更改密码 重新设置 安装完成后会自动打开浏览器、如未打开可手动打开浏览器输入http://localhost:8080/login?from=%2F 点击Finder: 按红字提示路径无法打开Finder,是因为secrets访问权限问题。按红色框提示输入电脑密码解锁修改文件夹权限和initialAdminPassword文件权限即可访问$ command+shift+G: /Users/Shared/Jenkins/Home/ 复制initialAdminPassword内密码到输入框点继续进行下一步 此处是个bug。提示Jenkins实例离线、无法获取插件。【不要跳过插件安装】 如正常请看第9步骤 新打开一个tab页，输入网址http://localhost:8080/pluginManager/advanced,最下面有个【升级站点】，把其中的链接改成http://updates.jenkins.io/update-center.json就好了。 更换完成后点击立即获取。如获取成功则会提示 xx秒之前获取了更新信息。 此时刷新Jenkins页面还是会提示离线，打开【活动监视器】搜索java，然后强制退出。关闭java服务后再刷新页面就显示正常了。 此时为正常显示页面，按需求选择安装推荐或自定义安装即可 安装完成后创建一个管理员用户 创建完成后点击下一步，进入Jenkins。此时Jenkins已安装完成。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>持续构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个非常简洁好用的UIbutton扩展,快速设置button的image位置]]></title>
    <url>%2F2018%2F04%2F18%2FUIButton-Category%2F</url>
    <content type="text"><![CDATA[转自tbl00c开源的一个基础组件库GitHub1234567891011121314151617181920212223242526UIButton+Extensions.h#import &lt;UIKit/UIKit.h&gt;typedef NS_ENUM(NSInteger, TLButtonImagePosition) &#123; TLButtonImagePositionLeft = 0, //图片在左，文字在右，默认 TLButtonImagePositionRight = 1, //图片在右，文字在左 TLButtonImagePositionTop = 2, //图片在上，文字在下 TLButtonImagePositionBottom = 3, //图片在下，文字在上&#125;;@interface UIButton (Extensions)/** * image和title图文混排 * * @param position 图片的位置，默认left * @param spacing 图片和标题的间隔 * * @return 返回button最小的size * * 注意，需要先设置好image、title、font。网络图片需要下载完成后再调用此方法，或设置同大小的placeholder */- (CGSize)setButtonImagePosition:(TLButtonImagePosition)position spacing:(CGFloat)spacing;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647UIButton+Extensions.m@implementation UIButton (Extensions)- (CGSize)setButtonImagePosition:(TLButtonImagePosition)position spacing:(CGFloat)spacing&#123; CGSize imageSize = self.imageView.image.size; CGSize titleSize = [self.titleLabel.text sizeWithAttributes:@&#123;NSFontAttributeName : self.titleLabel.font&#125;]; CGSize buttonSize = CGSizeZero; if (position == TLButtonImagePositionLeft || position == TLButtonImagePositionRight) &#123; if (position == TLButtonImagePositionLeft) &#123; self.imageEdgeInsets = UIEdgeInsetsMake(0, -spacing/2, 0, spacing/2); self.titleEdgeInsets = UIEdgeInsetsMake(0, spacing/2, 0, -spacing/2); &#125; else &#123; self.imageEdgeInsets = UIEdgeInsetsMake(0, titleSize.width + spacing/2, 0, -(titleSize.width + spacing/2)); self.titleEdgeInsets = UIEdgeInsetsMake(0, -(imageSize.height + spacing/2), 0, imageSize.height + spacing/2); &#125; buttonSize.width = imageSize.width + titleSize.width + spacing; buttonSize.height = MAX(imageSize.height, titleSize.height); &#125; else &#123; CGFloat imageOffsetX = titleSize.width &gt; imageSize.width ? (titleSize.width - imageSize.width) / 2.0 : 0; CGFloat imageOffsetY = imageSize.height / 2; CGFloat titleOffsetXR = titleSize.width &gt; imageSize.width ? 0 : (imageSize.width - titleSize.width) / 2.0; CGFloat titleOffsetX = imageSize.width + titleOffsetXR; CGFloat titleOffsetY = titleSize.height / 2; if (position == TLButtonImagePositionTop) &#123; self.imageEdgeInsets = UIEdgeInsetsMake(-imageOffsetY, imageOffsetX, imageOffsetY, -imageOffsetX); self.titleEdgeInsets = UIEdgeInsetsMake(titleOffsetY, -titleOffsetX, -titleOffsetY, -titleOffsetXR); &#125; else &#123; self.imageEdgeInsets = UIEdgeInsetsMake(imageOffsetY, imageOffsetX, -imageOffsetY, -imageOffsetX); self.titleEdgeInsets = UIEdgeInsetsMake(-titleOffsetY, -titleOffsetX, titleOffsetY, -titleOffsetXR); &#125; buttonSize.width = MAX(imageSize.width, titleSize.width); buttonSize.height = imageSize.height + titleSize.height + spacing; &#125; return buttonSize;&#125;@end]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS常见面试题]]></title>
    <url>%2F2018%2F04%2F16%2FInterview%2F</url>
    <content type="text"><![CDATA[内存管理 说一下内存管理中你经常用的几个修饰符assign “设置方法” 只会执行针对“纯量”的简单赋值操作。strong 此特质表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。weak 此特质表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指的对象遭到推毁时，属性值也会清空。assigin 可以用非OC对象,而weak必须用于OC对象。在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理。自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。unsafe_unretained 此特质的语义和assign相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”，当目标对象遭到推毁时，属性值不会自动清空，这一点与weak有区别。copy 此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是设置方法并不保留新值，而是将其“拷贝”。当属性类型为NSString*时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”，就应该在设置新属性值时拷贝一份。NSString、NSArray、NSDictionary可变类型常用copy，block也常用copy Nsstring用copy的原因是什么？这主要是为了防止NSString被修改。NSMutableString是NSStrig的子类，当NSString的赋值来源也是NSString时，strong和copy的作用相同，都是给复制来源的引用计数加1，当NSStrig的赋值来源是NSMutableString时，copy会做深拷贝，即重新生成一个新的对象，修改赋值来源不会影响NSString的值。举个例子：A-&gt;B A中的一个MutableString给B中的一个Property(NSString类型)赋值 首先是能接受的，父类可以接受子类，如果是strong，仅仅是生成一个指针，计数器加一，然后指向那个MutableString。如果NSString改变，B中那个跟着改变，因为是同一块内存区域。而选择Copy相当于又生成了一个NSString，与A中的MutableString独立。 Block为什么使用copy修饰?默认情况下，block是存档在栈中，可能被随时回收，通过copy操作可以使其在堆中保留一份, 相当于一直强引用着, 防止出现内存泄露的情况。当block中需要用到self时或者说需要弱引用的时候，通过weak或者unsafe_unretained. 但是当需要强化的时候，比如说，在block中有延迟执行的操作的时候就必须将其弱化，需要用__strong来修饰就可以了。 **ARC中是怎么实现自动释放的?这个时候我说的是，系统自动释放，但是会追加被问到系统是怎么释放的，我说是没有引用计数就自动释放了，但是会问到，系统是怎么知道引用计数为零需要释放了，这个才是问题的关键，这个时候应该回答说，这是被runloop控制的，每个任务都有自己的线程来完成，而每个线程都有自己对于的runloop，当一个任务结束的时候，就是runloop循环结束的时候会访问引用计数，就是还有没有被访问着，如果没有的话，就说明是零了，就会告诉系统为零需要释放，然后就会放到自动释放池中等待在一定的时间一起释放掉这些对象。 KVO-KVC 简述KVO的实现原理（不要简单的说出文字原理，方法名一定要说）kvo是基于runtime机制实现的，是通过监听属性来做相应的操作当某个类的对象第一次被观察时，系统会在其运行期间动态的创建一个子类，在这个子类中重写基类中任何被观察属性的setter方法，在set方法中通知监听observe。即通过调用[self willchangeValueForKey:“key”];和[self didChangeValueForKey:“key”];这两个方法会主动调用监听者内部的-（void）observeValueForKeyPath这个方法，从而实现监听。 简述KVC的实现原理Kvc是间接通过字符串类型的key获取对应的属性值.KVC的优点可以访问私有属性间接修改私有属性可以访问id类型任何类型的属性值 valueForKey和valueForKeyPath的区别keyPath包含了key的功能valueForKeyPath可以访问对象的对象，但是valueForKey不可以，只能访问当前对象的属性keyPath可以计算数组的长度 Block Block为什么使用copy修饰默认情况下，block是存放在栈中，可能被随时回收，通过copy操作可以使其在堆中保留一份, 相当于一直强引用着, 防止出现内存泄露的情况。当block中需要用到self时或者说需要弱引用的时候，通过weak或者unsafe_unretained. 但是当需要强化的时候，比如说，在block中有延迟执行的操作的时候就必须将其弱化，需要用__strong来修饰就可以了 如果block体外面定义个一个int类型的a=10，在block体里面修改a = 20，此时a是多少，为什么，应该怎么做a是10，因为局部变量修饰的值，在block体里面取得是值，而不是地址，在后面无论怎么修改都是取到新的值，应该用__block来修饰，这样就是取地址了。（还有的面试官会问，假如在block体外面用static修饰的话或者是在头文件中定义这个a呢，这个时候记住一点，除了局部修饰的block外面的值是取值，别的都是取址都是可以发生改变的） 在block中有一个用GCD修饰的线程，需要延时加载，这个时候会不会有什么问题，该怎么操作。会可能出现野指针，也就是对象被提前释放了，是为了避免在 block 的执行过程中，突然出现 self 被释放的尴尬情况。通常情况下，如果不这么做的话，还是很容易出现一些奇怪的逻辑，甚至闪退.防止这个，需要用到__strong来强引用一下。在延迟之后需要用到的时候不会被释放掉。 第三方框架和原理 简述SDWebImage的实现原理（这个时候不要只是答文字，重要api需要说出来）1) 入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。2) 进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:3) 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。4) SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。5) 如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。6) 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。7) 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。8) SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。9) 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片, 回调 imageCache:didNotFindImageForKey:userInfo:。10) 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。11) 图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。12) connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。13) connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。14) 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。15) 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。16) 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。17) 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。 SDWebImage内部可以自己清理缓存吗？SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片 SDWebImage怎么预先下载图片，方便后续使用?提供了SDWebImagePrefetcher 可以预先下载图片，方便后续使用。 下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）大部分的下拉刷新控件，都是用contentInset实现的。默认情况下，如果一个UIScrollView的左上角在导航栏的正下方，那么它的contentInset是64，而contentOffset是-64。继续下拉的话，contentOffset就会越来越小，如果上滑，contentOffset就会增大，直到左上角达到屏幕的左上角时，contentOffset刚好为0默认情况下，如果下拉一个UIScrollView，在松手之后，会弹回初始的位置（导航栏下方）。而大部分的下拉刷新控件，都是将自己放在UIScrollView的上方，起始y设置成负数，所以平时不会显示出来，只有下拉的时候才会出现，放开又会弹回去。然后在loading的时候，临时把contentInset增大，相当于把UIScrollView往下挤，于是下拉刷新的控件就会显示出来，然后刷新完成之后，再把contentInset改回原来的值，实现回弹的效果 数据存储 为什么应用存在沙盒中iOS本地化存储的数据保存在沙盒中 ，每个应用的沙盒是独立，结构是相同的，这样比较安全（我没回答上来，面试官给说的答案，不知道正确性） 存储方式1）Plist存储：Plist文件的Type可以是字典NSDictionary或数组NSArray，也就是说可以把字典或数组直接写入到文件中。NSString、NSData、NSNumber等类型，也可以使用writeToFile:atomically:方法直接将对象写入文件中，只是Type为空。2）NSUserDefaults，一般的登录注册的数据保存这个里面3）NSKeyedArchiver归档 / NSKeyedUnarchiver解档4) 归档和解档会在写入、读出数据之前进行序列化、反序列化，数据的安全性相对高一些。&emsp;&emsp;1&gt; 对单个简单对象进行归档/解档，当然，也可以存储NSArray，NSDictionary等对象。&emsp;&emsp;2&gt; 对多个对象进行归档/解档&emsp;&emsp;3&gt; 归档保存自定义对象。定义一个Person类，如果想对person进行归档解档，首先要让Person遵守协议。4）SQLite3&emsp;&emsp;1&gt; 首先需要添加库文件libsqlite3.0.tbd&emsp;&emsp;2&gt; 导入头文件#import &lt;sqlite3.h&gt;&emsp;&emsp;3&gt; 打开数据库&emsp;&emsp;4&gt; 创建表&emsp;&emsp;5&gt; 对数据表进行增删改查操作&emsp;&emsp;6&gt; 关闭数据库 FMDB和CoraData的区别FMDB是oc方式来封装c语言的sqlite，还是需要编写sqlite语句，CoreData是oc方式来封装c语言的sqlite，不用编写任何sqlite语句，自动根据对象类型和属性名生成对应的sqlite语句这两个的区别：CoreData不用编写sqlite语句，CoreData是不可控的，以为自动生成，会有很多不必要的属性，FMDB可以自己控制。 用sql语句怎么增加或者删除一个字段1）增加表字段：ALTER TABLE 表名 ADD COLUMN字段名字段类型2）删除表字段：ALTER TABLE 表名 DROP COLUMN字段名 字段类型3）x修改表字段：ALTER TABLE 表名 RENAME COLUMN旧字段名 to 新字段名 沙盒中存储文件都包括什么，都是怎么存放的（有一个问了这个问题）1)Application :存放程序源文件，上架前经过数字签名，上架后不可修改2）Document：常用目录，iCloud备份目录，存放数据，这里不能缓存文件，否则上架不被通过3）Library：&emsp;&emsp;1&gt; Caches:存放 体积大又不需要备份的数据，SDWebImage缓存路径就是这个&emsp;&emsp;2&gt; Preference:设置目录，iCloud会备份设置信息4）tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能 Runloop（这个具体没什么问题，看文档吧） 定义RunLoop的实质是一个死循环，用于保证程序的持续运行，只有当程序退出的时候才会结束（由main函数开启主线程的RunLoop） 作用保持程序的持续运行处理App中的各种事件（触摸、定时器、Selector事件）节省CPU资源，提高程序性能（该做事做事，没事做休息）使用NSRunLoop（面向对象）或者CFRunLoopRef（底层C语言） RunLoop的原理RunLoop开启一个循环事件，并接受输入事件，接受的事件来自两种不同的来源：输入源（input source）(传递异步事件)定时源（timer source）(传递同步事件)RunLoop接收到消息后采用handlePort、customSrc、mySelector和timerFired四个方法处理对应的事件当RunLoop没有接收到消息时，则进入休眠状态，以保持程序持续运行 多线程 NSOperation和GCD的区别1）GCD是基于c的底层api，NSOperation属于object-c类。ios首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。2）GCD优点：GCD主要与block结合使用。代码简洁高效。执行效率稍微高点。3）NSOperation相对于GCD：&emsp;&emsp;1&gt;，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在GCD基础上实现的，只不过是GCD更高一层的抽象。&emsp;&emsp;2&gt;，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。&emsp;&emsp;3&gt;NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）&emsp;&emsp;4&gt;GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。4)使用NSOperation的情况：各个操作之间有依赖关系、操作需要取消暂停、并发管理、控制操作之间优先级，限制同时能执行的线程数量.让线程在某时刻停止/继续等。5)使用GCD的情况：一般的需求很简单的多线程操作，用GCD都可以了，简单高效。 设计模式 单例（这个需要会写，两种写法，好几次让手写1）写法一：//提供一个static修饰的全局变量，强引用着已经实例化的单例对象实例 123456789101112131415161718192021222324252627282930313233343536static FileManager* sharedInstance = nil;//类方法，返回一个单例对象+(FileManager*) sharedInstance&#123; @synchronized(self) &#123; if (sharedInstance == nil) &#123; sharedInstance = [[self alloc] init]; //注意：这里建议使用self,而不是直接使用类名Tools（考虑继承） &#125; &#125; return sharedInstance;&#125;//保证永远只分配一次存储空间+(id)allocWithZone:(NSZone *)zone&#123; //使用加锁的方式，保证只分配一次存储空间 @synchronized(self)&#123; if(sharedInstance == nil)&#123; sharedInstance = [super allocWithZone:zone]; return sharedInstance; // assignment and return on first allocation &#125; &#125; return nil; //on subsequent allocation attempts return nil&#125;//让代码更加的严谨-(id)copyWithZone:(NSZone *)zone&#123; return self;&#125;2）写法二用GCDstatic SwitchMenuViewModel * segTitles = nil;+(instancetype)sharedSegTitles&#123; static dispatch_once_t once; dispatch_once(&amp;once,^&#123; segTitles = [[SwitchMenuViewModel alloc]init]; &#125;); return segTitles;&#125; 通知NSNotification 是iOS中一个调度消息通知的类,采用单例模式设计,在程序中实现传值、回调等地方应用很广。在iOS中，NSNotification &amp; NSNotificationCenter是使用观察者模式来实现的用于跨层传递消息。对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变，也不知道对象是什么&emsp;&emsp;1&gt; 向观察者中心添加观察者 123456789101112131415161718192021222324252627282930313233-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self addNotifications];//添加通知&#125;-(void)addNotifications&#123; //退出企业 [[NSNotificationCenter defaultCenter] removeObserver:self name:NT_Exit_Company object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(ExitCompany:) name:NT_Exit_Company object:nil];&#125;// 移除通知-(void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self removeNotifications];//添加通知&#125;-(void)removeNotifications&#123; [[NSNotificationCenter defaultCenter]removeObserver:self name:NT_Exit_Company object:nil];&#125;&amp;emsp;&amp;emsp;2&gt; 通知中心向观察者发送消息[[NSNotificationCenter defaultCenter] postNotificationName:NT_Exit_Company object:dict];&amp;emsp;&amp;emsp;3&gt;实现通知之后的操作// 收到推送之后刷新界面-(void)RefreashHomeVC:(NSNotification *) obj&#123; lable = obj.object; [self ToDetectNetWork];//重新加载&#125; Runtimeruntime是一套底层的C语言API，是一个实现Objective-C语言的C库。它是一门编译型语言、也是一门动态型的语言（这里强调下OC是静态类型语言），OC之所以能够做到即是编译型语言，又能做到动态语言，就是得益于runtime的机制。所谓runtime机制就是在C语言里边的函数调用到了OC里边就变成了另外一个名字，称之为消息发送。即objc_msgSend，这就是利用了runtime的消息机制特性，完成了一个动态调用的过程。还有一个重要的作用，可以交换两个方法的实现，代码是：method_exchangeImplementations 性能优化 用ARC管理内存 在正确的地方使用 reuseIdentifier 尽量把views设置为透明 避免过于庞大的XIB 不要阻塞主线程 在Image Views中调整图片大小 选择正确的使用Collection 重用和延迟加载(lazy load) Views 避免日期格式转换 渲染方法 处理内存警告 避免反复处理数据 选择正确的数据格式 正确设定背景图片 减少使用Web特性 优化Table View 使用Autorelease Pool 选择是否缓存图片 NSTimer （这个被问的多） Nstimer计时一定是安全的吗，不安全怎么办答案是否定的，而且有时候你会发现实际的触发时间跟你想象的差距还比较大。NSTimer不是一个实时系统，因此不管是一次性的还是周期性的timer的实际触发事件的时间可能都会跟我们预想的会有出入。差距的大小跟当前我们程序的执行情况有关系，比如可能程序是多线程的，而你的timer只是添加在某一个线程的runloop的某一种指定的runloopmode中，由于多线程通常都是分时执行的，而且每次执行的mode也可能随着实际情况发生变化。假设你添加了一个timer指定2秒后触发某一个事件，但是签好那个时候当前线程在执行一个连续运算(例如大数据块的处理等)，这个时候timer就会延迟到该连续运算执行完以后才会执行。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会和后面的触发进行合并，即在一个周期内只会触发一次。但是不管该timer的触发时间延迟的有多离谱，他后面的timer的触发时间总是倍数于第一次添加timer的间隙 nstimer在使用的时候，应该注意什么1）必须得把timer添加到runloop中，它才会生效2）要让timer生效，必须保证该线程的runloop已启动，而且其运行的runloopmode也要匹配3）划动下面的tableview没有变化，是为什么？**经常被问到这个问题在tableview滑动时timer就是显示暂停，原因是timer的这个简便构造方法把timer加入了NSRunLoopDefaultMode上，而tableview在滑动时只会处理UITrackingRunLoopMode，RunLoop并没有处理timer事件。解决的办法是将timer绑定到NSRunLoopCommonModes上，通过以下方法构造timer：nstimer在使用的时候，应该注意什么 延伸问题: 什么是死锁，举例说明互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住比如下面的代码： 12345dispatch_sync(_queue, ^&#123; &amp;emsp;dispatch_sync(_queue, ^&#123; //do something &#125;);&#125;) frame和bounds的区别frame是指的该view在父view坐标系统中的位置和大小bounds是该view在本身坐标系统中的位置和大小 什么是三次握手（笔试）第一次握手：建立连接时，客户端发送同步序列编号到服务器，并进入发送状态，等待服务器确认第二次握手：服务器收到同步序列编号，确认并同时自己也发送一个同步序列编号，+确认标志，此时服务器进入接受状态第三次握手：客户端收到服务器发送的包，并向服务器发送确认标志，随后链接成功。 有a b c d 四个异步请求，如何在a b c 都完成之后去执行d 1234567891011121) 创建队列queue dispatch_queue_t queue = (dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0))2) 创建组group dispatch_group_t group = dispatch_group_creat();3) 将queue和group加入到执行的任务中 并执行a b cdispatch_group_async(group,queue,^&#123;//任务a&#125;)dispatch_group_async(group,queue,^&#123;//任务b&#125;)dispatch_group_async(group,queue,^&#123;//任务c&#125;)4) 完了之后引用dispatch_group_notify(group,dispatch_get_main_queue()),^&#123; //执行d操作&#125;); UIView 和 CALayer的区别 UIView集成UIResponder，因此UIView可以处理响应时间，而CALayer集成NSObject，所以它只负责内容的创建、绘制。 UIView负责对内容的管理，而CALayer则是对内容的绘制。 UIView中的位置属性只有frame、bounds、center，而CALyaer除了具备这些属性之外还有anchorPoint、position。 通过修改CALayer可以实现UIView无法实现的很多高级功能。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发常见bug]]></title>
    <url>%2F2018%2F03%2F26%2Fquestion%2F</url>
    <content type="text"><![CDATA[使用第三方框架Alamofire、Kingfisher 等等时报错dyld: Library not loaded Reason: image not found 在Xcode中的Build Phases中的Copy Files项中，将你要引用的framework拖到“Linked Frameworks and Libraries“中 把Build Phases 里Social.framework后边的选项修改成为Optional就可以了 Swift4.0 中使用KVC给model赋值时无法赋值 在model中给属性前添加@objc关键字 在iOS 11上给navigationBar的titleView添加searchBar导致navigationBar高度增高 自定义一个view，然后将searchBar添加到自定义view上，再将自定义view赋值给titleView UISearchBar进入编辑状态时向上偏移设置searchController.hidesNavigationBarDuringPresentation = NO; UISearchController取消遮盖蒙版设置searchController.dimsBackgroundDuringPresentation = NO; 如何监听UISearchController遮盖点击事件点击遮盖时就是将searchController隐藏、所以监听UISearchController消失的事件即可 (void)willDismissSearchController:(UISearchController *)searchController{ // TODO:} 解决tableView的sectionIndex和searchBar冲突问题把searchBar加在一个UIView上，然后把UIView加在tableHeaderView上，同时sectionIndex背景色要清除 UIView *headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kScreen_width, 56)];[headerView addSubview:self.searchController.searchBar];[self.tableView setTableHeaderView:headerView]; [self.tableView setSectionIndexBackgroundColor:[UIColor clearColor]];]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Coding.net/Github搭建自己的博客]]></title>
    <url>%2F2018%2F03%2F02%2FSetBlog%2F</url>
    <content type="text"><![CDATA[因为gitHub服务器在国外，而且gitHub不让百度的爬虫爬取内容，导致了搭建在gitHub上的博客访问速度非常慢，博客不会被百度搜索到。所以建议选择国内的Coding.net来搭建博客。搭建方法几乎是一致的。下面讲一下如何基于Coding.net搭建自己的博客。 安装Hexo1$ npm install hexo-cli -g 初始化blog1$ hexo init blog 启动预览blog12$ cd blog$ hexo server 在浏览器输入：http://localhost:4000/ 显示如下图就成功了 设置33种主题样式搭建博客大全]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>记事</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE HTML&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于本站]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[博客宗旨: 把最实用的经验，分享给最需要的读者，希望每一位来访的朋友都能有所收获！]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
