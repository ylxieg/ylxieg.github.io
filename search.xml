<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>如何优化复杂tableView卡顿问题？</title>
      <link href="/2019/03/11/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%A4%8D%E6%9D%82tableView%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<h4 id="导致tableView卡顿的原因："><a href="#导致tableView卡顿的原因：" class="headerlink" title="导致tableView卡顿的原因："></a>导致tableView卡顿的原因：</h4><ol><li>cellForRowAtIndexPath:方法中处理了过多业务</li><li>cell的subview层级太复杂，做了大量透明处理  </li><li>cell的height动态变化时计算方式不对</li></ol><h4 id="优化tableView："><a href="#优化tableView：" class="headerlink" title="优化tableView："></a>优化tableView：</h4><ol><li>cell的行高不是固定值，需要计算，则要尽可能缓存行高值，避免重复计算行高。因为 heightForRowAtIndexPath:是调用最频繁的方法。</li><li>滑动时按需加载，这个在大量图片展示，网络加载的时候很管用!(SDWebImage 已经实现异 步加载，配合这条性能杠杠的)。</li><li>正确使用 reuseIdentifier 来重用 Cells</li><li>尽量少用或不用透明图层</li><li>如果 Cell 内现实的内容来自 web，使用异步加载，缓存请求结果</li><li>减少 subviews 的数量</li><li>在 heightForRowAtIndexPath:中尽量不使用 cellForRowAtIndexPath:，如果你需要用到它， 只用一次然后缓存结果</li><li>所有的子视图都预先创建，如果不需要显示可以设置 hidden，尽量少动态给 Cell 添加 View </li><li>颜色不要使用 alph</li><li>栅格化，</li><li>cell 异步加载图片以及缓存 </li><li>cell 的 subViews 的各级 opaque 值要设成 YES，尽量不要包含透明的子 View<br>opaque 用于辅助绘图系统，表示 UIView 是否透明。在不透明的情况下，渲染视图时需要快速 地渲染，以􏰀高性能。渲染最慢的操作之一是混合(blending)。􏰀高性能的方法是减少混合操 作的次数，其实就是 GPU 的不合理使用，这是硬件来完成的(混合操作由 GPU 来执行，因为这 个硬件就是用来做混合操作的，当然不只是混合)。 优化混合操作的关键点是在平衡 CPU 和 GPU 的负载。还有就是 cell 的 layer 的 shouldRasterize 要设成 YES。</li><li>不要将 tableview 的背景颜色设置成一个图片。这回严重影响 UITableView 的滑动速度。在 限时免费搜索里，我曾经翻过一个错误:self.tableView_.backgroundColor = [UIColorcolorWithPatternImage:[UIImageimageNamed:@”background.png”]]; 通过这种方式 设置 UITableView 的背景颜色会严重影响 UTIableView 的滑动流畅性。修改成 self.tableView_.backgroundColor = [UIColor clearColor];之后，fps 从 43 上升到 60 左右。 滑动比较流畅。</li><li>异步绘制</li></ol><blockquote><p>(1) 在绘制字符串时，尽可能使用 drawAtPoint: withFont:，而不要使用更复杂的 drawAtPoint:(CGPoint)point forWidth:(CGFloat)width withFont:(UIFont *)font lineBreakMode:(UILineBreakMode)lineBreakMode; 如果要绘制过长的字符串，建议自己先截 断，然后使用 drawAtPoint: withFont:方法绘制。<br>(2) 在绘制图片时，尽量使用 drawAtPoint，而不要使用 drawInRect。drawInRect 如果在绘 制过程中对图片进行放缩，会特别消耗 CPU。<br>(3) 其实，最快的绘制就是你不要做任何绘制。有时通过 UIGraphicsBeginImageContextWithOptions() 或者 CGBitmapContextCeate() 创建位图会显 得更有意义，从位图上面抓取图像，并设置为 CALayer 的内容。如果你必须实现 -drawRect:，并且你必须绘制大量的东西，这将占用时间。<br>(4) 如果绘制 cell 过程中，需要下载 cell 中的图片，建议在绘制 cell 一段时间后再开启图 片下载任务。譬如先画一个默认图片，然后在 0.5S 后开始下载本 cell 的图片。<br>(5) 即使下载 cell 图片是在子线程中进行，在绘制 cell 过程中，也不能开启过多的子线程。 最好只有一个下载图片的子线程在活动。否则也会影响 UITableViewCell 的绘制，因而影响了 UITableViewCell 的滑动速度。(建议结合使用 NSOpeartion 和 NSOperationQueue 来下载图片， 如果想尽可能找的下载图片，可以把[self.queuesetMaxConcurrentOperationCount:4];)<br>(6) 最好自己写一个 cache，用来缓存 UITableView 中的 UITableViewCell，这样在整个 UITableView 的生命周期里，一个 cell 只需绘制一次，并且如果发生内存不足，也可以有效的 释放掉缓存的 cell。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jenkins持续构建-采坑大全-Mac版</title>
      <link href="/2018/05/30/Jenkins/"/>
      <content type="html"><![CDATA[<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。(百度百科🤦‍♀️)</p><h3 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p><a href="https://jenkins.io/download/" target="_blank" rel="noopener">Jenkins官网下载</a></p><ol><li><p>选择相对应的环境下载<br> <img src="/2018/05/30/Jenkins/jenkins.png" alt="Jenkins官网"></p></li><li><p>打开下载好的.pkg文件、狂点下一步即可<br>安装完成后系统会默认生成一个<a href="#">Jenkins用户</a>，Jenkins账户密码可在 <a href="#">系统偏好设置-用户    与群组-其他用户-管理员-更改密码</a> 重新设置<br> <img src="/2018/05/30/Jenkins/1.png" alt="安装步骤"></p></li><li><p>安装完成后会自动打开浏览器、如未打开可手动打开浏览器输入<a href="http://localhost:8080/login?from=%2F" target="_blank" rel="noopener">http://localhost:8080/login?from=%2F</a><br> <img src="/2018/05/30/Jenkins/2.png" alt="安装成功"></p></li><li><p>点击Finder: 按红字提示路径无法打开Finder,是因为secrets访问权限问题。按红色框提示输入电脑密码解锁修改文件夹权限和initialAdminPassword文件权限即可访问<br><code>$ command+shift+G: /Users/Shared/Jenkins/Home/</code><br> <img src="/2018/05/30/Jenkins/3.png" alt="管理员密码"></p></li><li><p>复制initialAdminPassword内密码到输入框点继续进行下一步<br> <img src="/2018/05/30/Jenkins/4.png" alt="解锁Jenkins"></p></li><li><p>此处是个bug。提示Jenkins实例离线、无法获取插件。【不要跳过插件安装】  如正常请看第9步骤<br> <img src="/2018/05/30/Jenkins/5.png" alt="Jenkins实例离线"></p></li><li><p>新打开一个tab页，输入网址<a href="http://localhost:8080/pluginManager/advanced" target="_blank" rel="noopener">http://localhost:8080/pluginManager/advanced</a>,最下面有个【升级站点】，把其中的链接改成<a href="http://updates.jenkins.io/update-center.json" target="_blank" rel="noopener">http://updates.jenkins.io/update-center.json</a>就好了。<br> <img src="/2018/05/30/Jenkins/6.png" alt="Jenkins实例离线"></p></li><li><p>更换完成后点击立即获取。如获取成功则会提示 xx秒之前获取了更新信息。<br> <img src="/2018/05/30/Jenkins/7.png" alt="Jenkins实例离线"></p></li><li><p>此时刷新Jenkins页面还是会提示离线，打开【活动监视器】搜索java，然后强制退出。关闭java服务后再刷新页面就显示正常了。<br> <img src="/2018/05/30/Jenkins/8.png" alt="Jenkins实例离线"></p></li><li><p>此时为正常显示页面，按需求选择安装推荐或自定义安装即可<br> <img src="/2018/05/30/Jenkins/9.png" alt="Jenkins实例离线"></p></li><li><p>安装完成后创建一个管理员用户<br><img src="/2018/05/30/Jenkins/10.png" alt="Jenkins实例离线"></p></li><li><p>创建完成后点击下一步，进入Jenkins。此时Jenkins已安装完成。<br><img src="/2018/05/30/Jenkins/11.png" alt="Jenkins实例离线"></p></li></ol>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续构建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个非常简洁好用的UIbutton扩展,快速设置button的image位置</title>
      <link href="/2018/04/18/UIButton-Category/"/>
      <content type="html"><![CDATA[<h4 id="转自tbl00c开源的一个基础组件库GitHub"><a href="#转自tbl00c开源的一个基础组件库GitHub" class="headerlink" title="转自tbl00c开源的一个基础组件库GitHub"></a>转自tbl00c开源的一个基础组件库<a href="https://github.com/tbl00c/TLKit.git" target="_blank" rel="noopener">GitHub</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">UIButton+Extensions.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, TLButtonImagePosition) &#123;</span><br><span class="line">    TLButtonImagePositionLeft = 0,              //图片在左，文字在右，默认</span><br><span class="line">    TLButtonImagePositionRight = 1,             //图片在右，文字在左</span><br><span class="line">    TLButtonImagePositionTop = 2,               //图片在上，文字在下</span><br><span class="line">    TLButtonImagePositionBottom = 3,            //图片在下，文字在上</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface UIButton (Extensions)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  image和title图文混排</span><br><span class="line"> *</span><br><span class="line"> *  @param  position    图片的位置，默认left</span><br><span class="line"> *  @param  spacing     图片和标题的间隔</span><br><span class="line"> *</span><br><span class="line"> *  @return     返回button最小的size</span><br><span class="line"> *</span><br><span class="line"> *  注意，需要先设置好image、title、font。网络图片需要下载完成后再调用此方法，或设置同大小的placeholder</span><br><span class="line"> */</span><br><span class="line">- (CGSize)setButtonImagePosition:(TLButtonImagePosition)position spacing:(CGFloat)spacing;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">UIButton+Extensions.m</span><br><span class="line"></span><br><span class="line">@implementation UIButton (Extensions)</span><br><span class="line"></span><br><span class="line">- (CGSize)setButtonImagePosition:(TLButtonImagePosition)position spacing:(CGFloat)spacing</span><br><span class="line">&#123;</span><br><span class="line">    CGSize imageSize = self.imageView.image.size;</span><br><span class="line">    CGSize titleSize = [self.titleLabel.text sizeWithAttributes:@&#123;NSFontAttributeName : self.titleLabel.font&#125;];</span><br><span class="line">    </span><br><span class="line">    CGSize buttonSize = CGSizeZero;</span><br><span class="line">    if (position == TLButtonImagePositionLeft || position == TLButtonImagePositionRight) &#123;</span><br><span class="line">        if (position == TLButtonImagePositionLeft) &#123;</span><br><span class="line">            self.imageEdgeInsets = UIEdgeInsetsMake(0, -spacing/2, 0, spacing/2);</span><br><span class="line">            self.titleEdgeInsets = UIEdgeInsetsMake(0, spacing/2, 0, -spacing/2);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            self.imageEdgeInsets = UIEdgeInsetsMake(0, titleSize.width + spacing/2, 0, -(titleSize.width + spacing/2));</span><br><span class="line">            self.titleEdgeInsets = UIEdgeInsetsMake(0, -(imageSize.height + spacing/2), 0, imageSize.height + spacing/2);</span><br><span class="line">        &#125;</span><br><span class="line">        buttonSize.width = imageSize.width + titleSize.width + spacing;</span><br><span class="line">        buttonSize.height = MAX(imageSize.height, titleSize.height);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        CGFloat imageOffsetX = titleSize.width &gt; imageSize.width ? (titleSize.width - imageSize.width) / 2.0 : 0;</span><br><span class="line">        CGFloat imageOffsetY = imageSize.height / 2;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        CGFloat titleOffsetXR = titleSize.width &gt; imageSize.width ? 0 : (imageSize.width - titleSize.width) / 2.0;</span><br><span class="line">        CGFloat titleOffsetX = imageSize.width + titleOffsetXR;</span><br><span class="line">        CGFloat titleOffsetY = titleSize.height / 2;</span><br><span class="line">        </span><br><span class="line">        if (position == TLButtonImagePositionTop) &#123;</span><br><span class="line">            self.imageEdgeInsets = UIEdgeInsetsMake(-imageOffsetY, imageOffsetX, imageOffsetY, -imageOffsetX);</span><br><span class="line">            self.titleEdgeInsets = UIEdgeInsetsMake(titleOffsetY, -titleOffsetX, -titleOffsetY, -titleOffsetXR);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            self.imageEdgeInsets = UIEdgeInsetsMake(imageOffsetY, imageOffsetX, -imageOffsetY, -imageOffsetX);</span><br><span class="line">            self.titleEdgeInsets = UIEdgeInsetsMake(-titleOffsetY, -titleOffsetX, titleOffsetY, -titleOffsetXR);</span><br><span class="line">        &#125;</span><br><span class="line">        buttonSize.width = MAX(imageSize.width, titleSize.width);</span><br><span class="line">        buttonSize.height = imageSize.height + titleSize.height + spacing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return buttonSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS常见面试题</title>
      <link href="/2018/04/16/Interview/"/>
      <content type="html"><![CDATA[<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ol><li><p>说一下内存管理中你经常用的几个修饰符<br>assign “设置方法” 只会执行针对“纯量”的简单赋值操作。<br>strong  此特质表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。<br>weak 此特质表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指的对象遭到推毁时，属性值也会清空。assigin 可以用非OC对象,而weak必须用于OC对象。在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理。自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。<br>unsafe_unretained  此特质的语义和assign相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”，当目标对象遭到推毁时，属性值不会自动清空，这一点与weak有区别。<br>copy 此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是设置方法并不保留新值，而是将其“拷贝”。当属性类型为NSString*时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”，就应该在设置新属性值时拷贝一份。<br>NSString、NSArray、NSDictionary可变类型常用copy，block也常用copy</p></li><li><p>Nsstring用copy的原因是什么？<br>这主要是为了防止NSString被修改。NSMutableString是NSStrig的子类，当NSString的赋值来源也是NSString时，strong和copy的作用相同，都是给复制来源的引用计数加1，当NSStrig的赋值来源是NSMutableString时，copy会做深拷贝，即重新生成一个新的对象，修改赋值来源不会影响NSString的值。<br>举个例子：A-&gt;B  A中的一个MutableString给B中的一个Property(NSString类型)赋值   首先是能接受的，父类可以接受子类，如果是strong，仅仅是生成一个指针，计数器加一，然后指向那个MutableString。如果NSString改变，B中那个跟着改变，因为是同一块内存区域。而选择Copy相当于又生成了一个NSString，与A中的MutableString独立。</p></li><li><p>Block为什么使用copy修饰?<br>默认情况下，block是存档在栈中，可能被随时回收，通过copy操作可以使其在堆中保留一份, 相当于一直强引用着, 防止出现内存泄露的情况。当block中需要用到self时或者说需要弱引用的时候，通过<strong>weak或者</strong>unsafe_unretained. 但是当需要强化的时候，比如说，在block中有延迟执行的操作的时候就必须将其弱化，需要用__strong来修饰就可以了。</p></li><li><p>**ARC中是怎么实现自动释放的?<br>这个时候我说的是，系统自动释放，但是会追加被问到系统是怎么释放的，我说是没有引用计数就自动释放了，但是会问到，系统是怎么知道引用计数为零需要释放了，这个才是问题的关键，这个时候应该回答说，这是被runloop控制的，每个任务都有自己的线程来完成，而每个线程都有自己对于的runloop，当一个任务结束的时候，就是runloop循环结束的时候会访问引用计数，就是还有没有被访问着，如果没有的话，就说明是零了，就会告诉系统为零需要释放，然后就会放到自动释放池中等待在一定的时间一起释放掉这些对象。</p></li></ol><h4 id="KVO-KVC"><a href="#KVO-KVC" class="headerlink" title="KVO-KVC"></a>KVO-KVC</h4><ol><li><p>简述KVO的实现原理（不要简单的说出文字原理，方法名一定要说）<br>kvo是基于runtime机制实现的，是通过监听属性来做相应的操作<br>当某个类的对象第一次被观察时，系统会在其运行期间动态的创建一个子类，在这个子类中重写基类中任何被观察属性的setter方法，在set方法中通知监听observe。<br>即通过调用<code>[self willchangeValueForKey:“key”];</code><br>和<code>[self didChangeValueForKey:“key”];</code>这两个方法会主动调用监听者内部的<br><code>-（void）observeValueForKeyPath</code>这个方法，从而实现监听。</p></li><li><p>简述KVC的实现原理<br>Kvc是间接通过字符串类型的key获取对应的属性值.<br>KVC的优点<br>可以访问私有属性<br>间接修改私有属性<br>可以访问id类型任何类型的属性值</p></li><li><p>valueForKey和valueForKeyPath的区别<br>keyPath包含了key的功能<br>valueForKeyPath可以访问对象的对象，但是valueForKey不可以，只能访问当前对象的属性<br>keyPath可以计算数组的长度</p></li></ol><h4 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h4><ol><li><p>Block为什么使用copy修饰<br>默认情况下，block是存放在栈中，可能被随时回收，通过copy操作可以使其在堆中保留一份, 相当于一直强引用着, 防止出现内存泄露的情况。<br>当block中需要用到self时或者说需要弱引用的时候，通过<strong>weak或者</strong>unsafe_unretained. 但是当需要强化的时候，比如说，在block中有延迟执行的操作的时候就必须将其弱化，需要用__strong来修饰就可以了</p></li><li><p>如果block体外面定义个一个int类型的a=10，在block体里面修改a = 20，此时a是多少，为什么，应该怎么做<br>a是10，因为局部变量修饰的值，在block体里面取得是值，而不是地址，在后面无论怎么修改都是取到新的值，应该用__block来修饰，这样就是取地址了。（还有的面试官会问，假如在block体外面用static修饰的话或者是在头文件中定义这个a呢，这个时候记住一点，除了局部修饰的block外面的值是取值，别的都是取址都是可以发生改变的）</p></li><li><p>在block中有一个用GCD修饰的线程，需要延时加载，这个时候会不会有什么问题，该怎么操作。<br>会可能出现野指针，也就是对象被提前释放了，是为了避免在 block 的执行过程中，突然出现 self 被释放的尴尬情况。通常情况下，如果不这么做的话，还是很容易出现一些奇怪的逻辑，甚至闪退.<br>防止这个，需要用到__strong来强引用一下。在延迟之后需要用到的时候不会被释放掉。</p></li></ol><h4 id="第三方框架和原理"><a href="#第三方框架和原理" class="headerlink" title="第三方框架和原理"></a>第三方框架和原理</h4><ol><li>简述SDWebImage的实现原理（这个时候不要只是答文字，重要api需要说出来）<br>1) 入口 <code>setImageWithURL:placeholderImage:options:</code> 会先把 placeholderImage 显示，<br>然后 SDWebImageManager 根据 URL 开始处理图片。<br>2) 进入 <code>SDWebImageManager-downloadWithURL:delegate:options:userInfo:</code>，交给 SDImageCache 从缓存查找图片是否已经下载 <code>queryDiskCacheForKey:delegate:userInfo:</code><br>3) 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调<br><code>imageCache:didFindImage:forKey:userInfo:</code> 到 SDWebImageManager。<br>4) SDWebImageManagerDelegate 回调 <code>webImageManager:didFinishWithImage:</code> 到 UIImageView+WebCache 等前端展示图片。<br>5) 如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。<br>6) 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。<br>7) 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。<br>8) SDImageCacheDelegate 回调 <code>imageCache:didFindImage:forKey:userInfo:</code>。进而回调展示图片。<br>9) 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片, 回调 <code>imageCache:didNotFindImageForKey:userInfo:</code>。<br>10) 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。<br>11) 图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<br>12) <code>connection:didReceiveData:</code> 中利用 ImageIO 做了按图片下载进度加载效果。<br>13) <code>connectionDidFinishLoading:</code> 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<br>14) 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br>15) 在主线程 <code>notifyDelegateOnMainThreadWithInfo:</code> 宣告解码完成，<br><code>imageDecoder:didFinishDecodingImage:userInfo:</code> 回调给 SDWebImageDownloader。<br><code>imageDownloader:didFinishWithImage:</code> 回调给 SDWebImageManager 告知图片下载完成。<br>16) 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<br>17) 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。</li><li>SDWebImage内部可以自己清理缓存吗？<br>SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片</li><li>SDWebImage怎么预先下载图片，方便后续使用?<br>提供了SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</li></ol><h4 id="下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）"><a href="#下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）" class="headerlink" title="下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）"></a>下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）</h4><p>大部分的下拉刷新控件，都是用contentInset实现的。默认情况下，如果一个UIScrollView的左上角在导航栏的正下方，那么它的contentInset是64，而contentOffset是-64。继续下拉的话，contentOffset就会越来越小，如果上滑，contentOffset就会增大，直到左上角达到屏幕的左上角时，contentOffset刚好为0<br>默认情况下，如果下拉一个UIScrollView，在松手之后，会弹回初始的位置（导航栏下方）。而大部分的下拉刷新控件，都是将自己放在UIScrollView的上方，起始y设置成负数，所以平时不会显示出来，只有下拉的时候才会出现，放开又会弹回去。然后在loading的时候，临时把contentInset增大，相当于把UIScrollView往下挤，于是下拉刷新的控件就会显示出来，然后刷新完成之后，再把contentInset改回原来的值，实现回弹的效果</p><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><ol><li>为什么应用存在沙盒中<br>iOS本地化存储的数据保存在沙盒中 ，每个应用的沙盒是独立，结构是相同的，这样比较安全（我没回答上来，面试官给说的答案，不知道正确性）</li><li>存储方式<br>1）Plist存储：Plist文件的Type可以是字典NSDictionary或数组NSArray，也就是说可以把字典或数组直接写入到文件中。<br>NSString、NSData、NSNumber等类型，也可以使用<code>writeToFile:atomically:</code>方法直接将对象写入文件中，只是Type为空。<br>2）NSUserDefaults，一般的登录注册的数据保存这个里面<br>3）NSKeyedArchiver归档 / NSKeyedUnarchiver解档<br>4) 归档和解档会在写入、读出数据之前进行序列化、反序列化，数据的安全性相对高一些。<br>&emsp;&emsp;1&gt; 对单个简单对象进行归档/解档，当然，也可以存储NSArray，NSDictionary等对象。<br>&emsp;&emsp;2&gt; 对多个对象进行归档/解档<br>&emsp;&emsp;3&gt; 归档保存自定义对象。定义一个Person类，如果想对person进行归档解档，首先要让Person遵守<nscoding>协议。<br>4）SQLite3<br>&emsp;&emsp;1&gt; 首先需要添加库文件libsqlite3.0.tbd<br>&emsp;&emsp;2&gt; 导入头文件#import &lt;sqlite3.h&gt;<br>&emsp;&emsp;3&gt; 打开数据库<br>&emsp;&emsp;4&gt; 创建表<br>&emsp;&emsp;5&gt; 对数据表进行增删改查操作<br>&emsp;&emsp;6&gt; 关闭数据库</nscoding></li><li>FMDB和CoraData的区别<br>FMDB是oc方式来封装c语言的sqlite，还是需要编写sqlite语句，<br>CoreData是oc方式来封装c语言的sqlite，不用编写任何sqlite语句，自动根据对象类型和属性名生成对应的sqlite语句<br>这两个的区别：CoreData不用编写sqlite语句，CoreData是不可控的，以为自动生成，会有很多不必要的属性，FMDB可以自己控制。</li><li>用sql语句怎么增加或者删除一个字段<br>1）增加表字段：<code>ALTER TABLE 表名 ADD COLUMN</code>字段名字段类型<br>2）删除表字段：<code>ALTER TABLE 表名 DROP COLUMN</code>字段名 字段类型<br>3）x修改表字段：<code>ALTER TABLE 表名 RENAME COLUMN</code>旧字段名 to 新字段名</li><li>沙盒中存储文件都包括什么，都是怎么存放的（有一个问了这个问题）<br>1)Application :存放程序源文件，上架前经过数字签名，上架后不可修改<br>2）Document：常用目录，iCloud备份目录，存放数据，这里不能缓存文件，否则上架不被通过<br>3）Library：<br>&emsp;&emsp;1&gt; Caches:存放 体积大又不需要备份的数据，SDWebImage缓存路径就是这个<br>&emsp;&emsp;2&gt; Preference:设置目录，iCloud会备份设置信息<br>4）tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能</li></ol><h4 id="Runloop（这个具体没什么问题，看文档吧）"><a href="#Runloop（这个具体没什么问题，看文档吧）" class="headerlink" title="Runloop（这个具体没什么问题，看文档吧）"></a>Runloop（这个具体没什么问题，看文档吧）</h4><ol><li>定义<br>RunLoop的实质是一个死循环，用于保证程序的持续运行，只有当程序退出的时候才会结束（由main函数开启主线程的RunLoop）</li><li>作用<br>保持程序的持续运行<br>处理App中的各种事件（触摸、定时器、Selector事件）<br>节省CPU资源，提高程序性能（该做事做事，没事做休息）<br>使用NSRunLoop（面向对象）或者CFRunLoopRef（底层C语言）</li><li>RunLoop的原理<br>RunLoop开启一个循环事件，并接受输入事件，接受的事件来自两种不同的来源：<br>输入源（input source）(传递异步事件)<br>定时源（timer source）(传递同步事件)<br>RunLoop接收到消息后采用handlePort、customSrc、mySelector和timerFired四个方法处理对应的事件<br>当RunLoop没有接收到消息时，则进入休眠状态，以保持程序持续运行</li></ol><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ol><li>NSOperation和GCD的区别<br>1）GCD是基于c的底层api，NSOperation属于object-c类。ios首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。<br>2）GCD优点：GCD主要与block结合使用。代码简洁高效。执行效率稍微高点。<br>3）NSOperation相对于GCD：<br>&emsp;&emsp;1&gt;，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在GCD基础上实现的，只不过是GCD更高一层的抽象。<br>&emsp;&emsp;2&gt;，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。<br>&emsp;&emsp;3&gt;NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）<br>&emsp;&emsp;4&gt;GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。<br>4)使用NSOperation的情况：各个操作之间有依赖关系、操作需要取消暂停、并发管理、控制操作之间优先级，限制同时能执行的线程数量.让线程在某时刻停止/继续等。<br>5)使用GCD的情况：一般的需求很简单的多线程操作，用GCD都可以了，简单高效。</li></ol><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ol><li><p>单例（这个需要会写，两种写法，好几次让手写<br>1）写法一：//提供一个static修饰的全局变量，强引用着已经实例化的单例对象实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static FileManager* sharedInstance = nil;</span><br><span class="line">//类方法，返回一个单例对象</span><br><span class="line">+(FileManager*) sharedInstance&#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (sharedInstance == nil) &#123;</span><br><span class="line">            sharedInstance = [[self alloc] init]; //注意：这里建议使用self,而不是直接使用类名Tools（考虑继承）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">//保证永远只分配一次存储空间</span><br><span class="line">+(id)allocWithZone:(NSZone *)zone&#123;</span><br><span class="line">    //使用加锁的方式，保证只分配一次存储空间</span><br><span class="line">    @synchronized(self)&#123;</span><br><span class="line">        if(sharedInstance == nil)&#123;</span><br><span class="line">            sharedInstance = [super allocWithZone:zone];</span><br><span class="line">            return sharedInstance;  // assignment and return on first allocation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil; //on subsequent allocation attempts return nil</span><br><span class="line">&#125;</span><br><span class="line">//让代码更加的严谨</span><br><span class="line">-(id)copyWithZone:(NSZone *)zone&#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2）写法二用GCD</span><br><span class="line">static SwitchMenuViewModel * segTitles = nil;</span><br><span class="line">+(instancetype)sharedSegTitles</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    dispatch_once(&amp;once,^&#123;</span><br><span class="line">        segTitles = [[SwitchMenuViewModel alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return segTitles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通知<br>NSNotification 是iOS中一个调度消息通知的类,采用单例模式设计,在程序中实现传值、回调等地方应用很广。在iOS中，NSNotification &amp; NSNotificationCenter是使用观察者模式来实现的用于跨层传递消息。<br>对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变，也不知道对象是什么<br>&emsp;&emsp;1&gt; 向观察者中心添加观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    [self addNotifications];//添加通知</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)addNotifications&#123;</span><br><span class="line">    //退出企业</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:NT_Exit_Company object:nil];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(ExitCompany:) name:NT_Exit_Company object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移除通知</span><br><span class="line">-(void)viewWillDisappear:(BOOL)animated  &#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    [self removeNotifications];//添加通知</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)removeNotifications</span><br><span class="line">&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter]removeObserver:self name:NT_Exit_Company object:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;2&gt; 通知中心向观察者发送消息</span><br><span class="line">[[NSNotificationCenter  defaultCenter] postNotificationName:NT_Exit_Company object:dict];</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;3&gt;实现通知之后的操作</span><br><span class="line">// 收到推送之后刷新界面</span><br><span class="line">-(void)RefreashHomeVC:(NSNotification *) obj</span><br><span class="line">&#123;</span><br><span class="line">    lable = obj.object;</span><br><span class="line">    [self ToDetectNetWork];//重新加载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>runtime是一套底层的C语言API，是一个实现Objective-C语言的C库。它是一门编译型语言、也是一门动态型的语言（这里强调下OC是静态类型语言），OC之所以能够做到即是编译型语言，又能做到动态语言，就是得益于runtime的机制。所谓runtime机制就是在C语言里边的函数调用到了OC里边就变成了另外一个名字，称之为消息发送。即objc_msgSend，这就是利用了runtime的消息机制特性，完成了一个动态调用的过程。还有一个重要的作用，可以交换两个方法的实现，代码是：method_exchangeImplementations</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ol><li>用ARC管理内存</li><li>在正确的地方使用 reuseIdentifier</li><li>尽量把views设置为透明</li><li>避免过于庞大的XIB</li><li>不要阻塞主线程</li><li>在Image Views中调整图片大小</li><li>选择正确的使用Collection</li><li>重用和延迟加载(lazy load) Views</li><li>避免日期格式转换</li><li>渲染方法</li><li>处理内存警告</li><li>避免反复处理数据</li><li>选择正确的数据格式</li><li>正确设定背景图片</li><li>减少使用Web特性</li><li>优化Table View</li><li>使用Autorelease Pool</li><li>选择是否缓存图片</li></ol><h4 id="NSTimer-（这个被问的多）"><a href="#NSTimer-（这个被问的多）" class="headerlink" title="NSTimer （这个被问的多）"></a>NSTimer （这个被问的多）</h4><ol><li>Nstimer计时一定是安全的吗，不安全怎么办<br>答案是否定的，而且有时候你会发现实际的触发时间跟你想象的差距还比较大。NSTimer不是一个实时系统，因此不管是一次性的还是周期性的timer的实际触发事件的时间可能都会跟我们预想的会有出入。差距的大小跟当前我们程序的执行情况有关系，比如可能程序是多线程的，而你的timer只是添加在某一个线程的runloop的某一种指定的runloopmode中，由于多线程通常都是分时执行的，而且每次执行的mode也可能随着实际情况发生变化。<br>假设你添加了一个timer指定2秒后触发某一个事件，但是签好那个时候当前线程在执行一个连续运算(例如大数据块的处理等)，这个时候timer就会延迟到该连续运算执行完以后才会执行。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会和后面的触发进行合并，即在一个周期内只会触发一次。但是不管该timer的触发时间延迟的有多离谱，他后面的timer的触发时间总是倍数于第一次添加timer的间隙</li><li>nstimer在使用的时候，应该注意什么<br>1）必须得把timer添加到runloop中，它才会生效<br>2）要让timer生效，必须保证该线程的runloop已启动，而且其运行的runloopmode也要匹配<br>3）划动下面的tableview没有变化，是为什么？<strong><em>**</em></strong>经常被问到这个问题<br>在tableview滑动时timer就是显示暂停，原因是timer的这个简便构造方法把timer加入了NSRunLoopDefaultMode上，而tableview在滑动时只会处理UITrackingRunLoopMode，RunLoop并没有处理timer事件。<br>解决的办法是将timer绑定到NSRunLoopCommonModes上，通过以下方法构造timer：nstimer在使用的时候，应该注意什么</li></ol><h4 id="延伸问题"><a href="#延伸问题" class="headerlink" title="延伸问题:"></a>延伸问题:</h4><ol><li><p>什么是死锁，举例说明<br>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住<br>比如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(_queue, ^&#123;</span><br><span class="line">    &amp;emsp;dispatch_sync(_queue, ^&#123;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>frame和bounds的区别<br>frame是指的该view在父view坐标系统中的位置和大小<br>bounds是该view在本身坐标系统中的位置和大小</p></li><li><p>什么是三次握手（笔试）<br>第一次握手：建立连接时，客户端发送同步序列编号到服务器，并进入发送状态，等待服务器确认<br>第二次握手：服务器收到同步序列编号，确认并同时自己也发送一个同步序列编号，+确认标志，此时服务器进入接受状态<br>第三次握手：客户端收到服务器发送的包，并向服务器发送确认标志，随后链接成功。</p></li><li><p>有a b c d 四个异步请求，如何在a b  c 都完成之后去执行d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1) 创建队列</span><br><span class="line">queue dispatch_queue_t  queue = (dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0))</span><br><span class="line">2) 创建组</span><br><span class="line">group dispatch_group_t group = dispatch_group_creat();</span><br><span class="line">3) 将queue和group加入到执行的任务中 并执行a  b  c</span><br><span class="line">dispatch_group_async(group,queue,^&#123;//任务a&#125;)</span><br><span class="line">dispatch_group_async(group,queue,^&#123;//任务b&#125;)</span><br><span class="line">dispatch_group_async(group,queue,^&#123;//任务c&#125;)</span><br><span class="line">4) 完了之后引用</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue()),^&#123;</span><br><span class="line">    //执行d操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="UIView-和-CALayer的区别"><a href="#UIView-和-CALayer的区别" class="headerlink" title="UIView 和 CALayer的区别"></a>UIView 和 CALayer的区别</h4><ol><li>UIView集成UIResponder，因此UIView可以处理响应时间，而CALayer集成NSObject，所以它只负责内容的创建、绘制。</li><li>UIView负责对内容的管理，而CALayer则是对内容的绘制。</li><li>UIView中的位置属性只有frame、bounds、center，而CALyaer除了具备这些属性之外还有anchorPoint、position。</li><li>通过修改CALayer可以实现UIView无法实现的很多高级功能。             </li></ol>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS开发常见bug</title>
      <link href="/2018/03/26/question/"/>
      <content type="html"><![CDATA[<h4 id="使用第三方框架Alamofire、Kingfisher-等等时报错dyld-Library-not-loaded-Reason-image-not-found"><a href="#使用第三方框架Alamofire、Kingfisher-等等时报错dyld-Library-not-loaded-Reason-image-not-found" class="headerlink" title="使用第三方框架Alamofire、Kingfisher 等等时报错dyld: Library not loaded Reason: image not found"></a>使用第三方框架Alamofire、Kingfisher 等等时报错dyld: Library not loaded Reason: image not found</h4><ol><li>在Xcode中的Build Phases中的Copy Files项中，将你要引用的framework拖到“Linked Frameworks and Libraries“中</li><li>把Build Phases 里Social.framework后边的选项修改成为Optional就可以了<br><img src="/2018/03/26/question/q1.png" alt="如图"></li></ol><h4 id="Swift4-0-中使用KVC给model赋值时无法赋值"><a href="#Swift4-0-中使用KVC给model赋值时无法赋值" class="headerlink" title="Swift4.0 中使用KVC给model赋值时无法赋值"></a>Swift4.0 中使用KVC给model赋值时无法赋值</h4><ol><li>在model中给属性前添加@objc关键字</li></ol><h4 id="在iOS-11上给navigationBar的titleView添加searchBar导致navigationBar高度增高"><a href="#在iOS-11上给navigationBar的titleView添加searchBar导致navigationBar高度增高" class="headerlink" title="在iOS 11上给navigationBar的titleView添加searchBar导致navigationBar高度增高"></a>在iOS 11上给navigationBar的titleView添加searchBar导致navigationBar高度增高</h4><ol><li>自定义一个view，然后将searchBar添加到自定义view上，再将自定义view赋值给titleView<br><img src="/2018/03/26/question/q2.png" alt="如图"></li></ol><h4 id="UISearchBar进入编辑状态时向上偏移"><a href="#UISearchBar进入编辑状态时向上偏移" class="headerlink" title="UISearchBar进入编辑状态时向上偏移"></a>UISearchBar进入编辑状态时向上偏移</h4><p><code>设置searchController.hidesNavigationBarDuringPresentation = NO;</code></p><h4 id="UISearchController取消遮盖蒙版"><a href="#UISearchController取消遮盖蒙版" class="headerlink" title="UISearchController取消遮盖蒙版"></a>UISearchController取消遮盖蒙版</h4><p><code>设置searchController.dimsBackgroundDuringPresentation = NO;</code></p><h4 id="如何监听UISearchController遮盖点击事件"><a href="#如何监听UISearchController遮盖点击事件" class="headerlink" title="如何监听UISearchController遮盖点击事件"></a>如何监听UISearchController遮盖点击事件</h4><p>点击遮盖时就是将searchController隐藏、所以监听UISearchController消失的事件即可<br><code></code></p><ul><li>(void)willDismissSearchController:(UISearchController *)searchController<br>{<br>  // TODO:<br>}<code></code></li></ul><h4 id="解决tableView的sectionIndex和searchBar冲突问题"><a href="#解决tableView的sectionIndex和searchBar冲突问题" class="headerlink" title="解决tableView的sectionIndex和searchBar冲突问题"></a>解决tableView的sectionIndex和searchBar冲突问题</h4><p>把searchBar加在一个UIView上，然后把UIView加在tableHeaderView上，同时sectionIndex背景色要清除</p><p><code></code><br>UIView *headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kScreen_width, 56)];<br>[headerView addSubview:self.searchController.searchBar];<br>[self.tableView setTableHeaderView:headerView];</p><p>[self.tableView setSectionIndexBackgroundColor:[UIColor clearColor]];<br><code></code></p>]]></content>
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo+Coding.net/Github搭建自己的博客</title>
      <link href="/2018/03/02/SetBlog/"/>
      <content type="html"><![CDATA[<p>　　因为gitHub服务器在国外，而且gitHub不让百度的爬虫爬取内容，导致了搭建在gitHub上的博客访问速度非常慢，博客不会被百度搜索到。所以建议选择国内的Coding.net来搭建博客。搭建方法几乎是一致的。下面讲一下如何基于Coding.net搭建自己的博客。　　</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="初始化blog"><a href="#初始化blog" class="headerlink" title="初始化blog"></a>初始化blog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="启动预览blog"><a href="#启动预览blog" class="headerlink" title="启动预览blog"></a>启动预览blog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd blog</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><img src="/2018/03/02/SetBlog/server.png" alt="如图"><br>在浏览器输入：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 显示如下图就成功了<br><img src="/2018/03/02/SetBlog/Hexo.jpg" alt="如图"></p><h3 id="设置33种主题样式"><a href="#设置33种主题样式" class="headerlink" title="设置33种主题样式"></a><a href="https://segmentfault.com/a/1190000009544924#articleHeader2" target="_blank" rel="noopener">设置33种主题样式</a></h3><h3 id="搭建博客大全"><a href="#搭建博客大全" class="headerlink" title="搭建博客大全"></a><a href="http://cherryblog.site/" target="_blank" rel="noopener">搭建博客大全</a></h3>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/02/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记事 </tag>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/404.html"/>
      <content type="html"><![CDATA[<p>&lt;!DOCTYPE HTML&gt;</p><html><br><head><br>  <meta http-equiv="content-type" content="text/html;charset=utf-8;"><br>  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><br>  <meta name="robots" content="all"><br>  <meta name="robots" content="index,follow"><br></head><br><body><br><br><script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="http://ylxie.top/" homepagename="回到我的主页"></script><br><br></body><br></html>]]></content>
    </entry>
    
    <entry>
      <title>关于本站</title>
      <link href="/about/index.html"/>
      <content type="html"><![CDATA[<p>博客宗旨: 把最实用的经验，分享给最需要的读者，希望每一位来访的朋友都能有所收获！</p>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/categories/index.html"/>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
