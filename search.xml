<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jenkins持续构建-采坑大全-Mac版]]></title>
    <url>%2F2018%2F05%2F30%2FJenkins%2F</url>
    <content type="text"><![CDATA[Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。(百度百科🤦‍♀️) Jenkins安装Jenkins官网下载 选择相对应的环境下载 打开下载好的.pkg文件、狂点下一步即可安装完成后系统会默认生成一个Jenkins用户，Jenkins账户密码可在 系统偏好设置-用户 与群组-其他用户-管理员-更改密码 重新设置 安装完成后会自动打开浏览器、如未打开可手动打开浏览器输入http://localhost:8080/login?from=%2F 点击Finder: 按红字提示路径无法打开Finder,是因为secrets访问权限问题。按红色框提示输入电脑密码解锁修改文件夹权限和initialAdminPassword文件权限即可访问$ command+shift+G: /Users/Shared/Jenkins/Home/ 复制initialAdminPassword内密码到输入框点继续进行下一步 此处是个bug。提示Jenkins实例离线、无法获取插件。【不要跳过插件安装】 如正常请看第9步骤 新打开一个tab页，输入网址http://localhost:8080/pluginManager/advanced,最下面有个【升级站点】，把其中的链接改成http://updates.jenkins.io/update-center.json就好了。 更换完成后点击立即获取。如获取成功则会提示 xx秒之前获取了更新信息。 此时刷新Jenkins页面还是会提示离线，打开【活动监视器】搜索java，然后强制退出。关闭java服务后再刷新页面就显示正常了。 此时为正常显示页面，按需求选择安装推荐或自定义安装即可 安装完成后创建一个管理员用户 创建完成后点击下一步，进入Jenkins。此时Jenkins已安装完成。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>持续构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个非常简洁好用的UIbutton扩展,快速设置button的image位置]]></title>
    <url>%2F2018%2F04%2F18%2FUIButton-Category%2F</url>
    <content type="text"><![CDATA[转自tbl00c开源的一个基础组件库GitHub1234567891011121314151617181920212223242526UIButton+Extensions.h#import &lt;UIKit/UIKit.h&gt;typedef NS_ENUM(NSInteger, TLButtonImagePosition) &#123; TLButtonImagePositionLeft = 0, //图片在左，文字在右，默认 TLButtonImagePositionRight = 1, //图片在右，文字在左 TLButtonImagePositionTop = 2, //图片在上，文字在下 TLButtonImagePositionBottom = 3, //图片在下，文字在上&#125;;@interface UIButton (Extensions)/** * image和title图文混排 * * @param position 图片的位置，默认left * @param spacing 图片和标题的间隔 * * @return 返回button最小的size * * 注意，需要先设置好image、title、font。网络图片需要下载完成后再调用此方法，或设置同大小的placeholder */- (CGSize)setButtonImagePosition:(TLButtonImagePosition)position spacing:(CGFloat)spacing;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647UIButton+Extensions.m@implementation UIButton (Extensions)- (CGSize)setButtonImagePosition:(TLButtonImagePosition)position spacing:(CGFloat)spacing&#123; CGSize imageSize = self.imageView.image.size; CGSize titleSize = [self.titleLabel.text sizeWithAttributes:@&#123;NSFontAttributeName : self.titleLabel.font&#125;]; CGSize buttonSize = CGSizeZero; if (position == TLButtonImagePositionLeft || position == TLButtonImagePositionRight) &#123; if (position == TLButtonImagePositionLeft) &#123; self.imageEdgeInsets = UIEdgeInsetsMake(0, -spacing/2, 0, spacing/2); self.titleEdgeInsets = UIEdgeInsetsMake(0, spacing/2, 0, -spacing/2); &#125; else &#123; self.imageEdgeInsets = UIEdgeInsetsMake(0, titleSize.width + spacing/2, 0, -(titleSize.width + spacing/2)); self.titleEdgeInsets = UIEdgeInsetsMake(0, -(imageSize.height + spacing/2), 0, imageSize.height + spacing/2); &#125; buttonSize.width = imageSize.width + titleSize.width + spacing; buttonSize.height = MAX(imageSize.height, titleSize.height); &#125; else &#123; CGFloat imageOffsetX = titleSize.width &gt; imageSize.width ? (titleSize.width - imageSize.width) / 2.0 : 0; CGFloat imageOffsetY = imageSize.height / 2; CGFloat titleOffsetXR = titleSize.width &gt; imageSize.width ? 0 : (imageSize.width - titleSize.width) / 2.0; CGFloat titleOffsetX = imageSize.width + titleOffsetXR; CGFloat titleOffsetY = titleSize.height / 2; if (position == TLButtonImagePositionTop) &#123; self.imageEdgeInsets = UIEdgeInsetsMake(-imageOffsetY, imageOffsetX, imageOffsetY, -imageOffsetX); self.titleEdgeInsets = UIEdgeInsetsMake(titleOffsetY, -titleOffsetX, -titleOffsetY, -titleOffsetXR); &#125; else &#123; self.imageEdgeInsets = UIEdgeInsetsMake(imageOffsetY, imageOffsetX, -imageOffsetY, -imageOffsetX); self.titleEdgeInsets = UIEdgeInsetsMake(-titleOffsetY, -titleOffsetX, titleOffsetY, -titleOffsetXR); &#125; buttonSize.width = MAX(imageSize.width, titleSize.width); buttonSize.height = imageSize.height + titleSize.height + spacing; &#125; return buttonSize;&#125;@end]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS常见面试题]]></title>
    <url>%2F2018%2F04%2F16%2FInterview%2F</url>
    <content type="text"><![CDATA[内存管理 说一下内存管理中你经常用的几个修饰符assign “设置方法” 只会执行针对“纯量”的简单赋值操作。strong 此特质表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。weak 此特质表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指的对象遭到推毁时，属性值也会清空。assigin 可以用非OC对象,而weak必须用于OC对象。在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理。自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。unsafe_unretained 此特质的语义和assign相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”，当目标对象遭到推毁时，属性值不会自动清空，这一点与weak有区别。copy 此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是设置方法并不保留新值，而是将其“拷贝”。当属性类型为NSString*时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”，就应该在设置新属性值时拷贝一份。NSString、NSArray、NSDictionary可变类型常用copy，block也常用copy Nsstring用copy的原因是什么？这主要是为了防止NSString被修改。NSMutableString是NSStrig的子类，当NSString的赋值来源也是NSString时，strong和copy的作用相同，都是给复制来源的引用计数加1，当NSStrig的赋值来源是NSMutableString时，copy会做深拷贝，即重新生成一个新的对象，修改赋值来源不会影响NSString的值。举个例子：A-&gt;B A中的一个MutableString给B中的一个Property(NSString类型)赋值 首先是能接受的，父类可以接受子类，如果是strong，仅仅是生成一个指针，计数器加一，然后指向那个MutableString。如果NSString改变，B中那个跟着改变，因为是同一块内存区域。而选择Copy相当于又生成了一个NSString，与A中的MutableString独立。 Block为什么使用copy修饰?默认情况下，block是存档在栈中，可能被随时回收，通过copy操作可以使其在堆中保留一份, 相当于一直强引用着, 防止出现内存泄露的情况。当block中需要用到self时或者说需要弱引用的时候，通过weak或者unsafe_unretained. 但是当需要强化的时候，比如说，在block中有延迟执行的操作的时候就必须将其弱化，需要用__strong来修饰就可以了。 **ARC中是怎么实现自动释放的?这个时候我说的是，系统自动释放，但是会追加被问到系统是怎么释放的，我说是没有引用计数就自动释放了，但是会问到，系统是怎么知道引用计数为零需要释放了，这个才是问题的关键，这个时候应该回答说，这是被runloop控制的，每个任务都有自己的线程来完成，而每个线程都有自己对于的runloop，当一个任务结束的时候，就是runloop循环结束的时候会访问引用计数，就是还有没有被访问着，如果没有的话，就说明是零了，就会告诉系统为零需要释放，然后就会放到自动释放池中等待在一定的时间一起释放掉这些对象。 KVO-KVC 简述KVO的实现原理（不要简单的说出文字原理，方法名一定要说）kvo是基于runtime机制实现的，是通过监听属性来做相应的操作当某个类的对象第一次被观察时，系统会在其运行期间动态的创建一个子类，在这个子类中重写基类中任何被观察属性的setter方法，在set方法中通知监听observe。即通过调用[self willchangeValueForKey:“key”];和[self didChangeValueForKey:“key”];这两个方法会主动调用监听者内部的-（void）observeValueForKeyPath这个方法，从而实现监听。 简述KVC的实现原理Kvc是间接通过字符串类型的key获取对应的属性值.KVC的优点可以访问私有属性间接修改私有属性可以访问id类型任何类型的属性值 valueForKey和valueForKeyPath的区别keyPath包含了key的功能valueForKeyPath可以访问对象的对象，但是valueForKey不可以，只能访问当前对象的属性keyPath可以计算数组的长度 Block Block为什么使用copy修饰默认情况下，block是存放在栈中，可能被随时回收，通过copy操作可以使其在堆中保留一份, 相当于一直强引用着, 防止出现内存泄露的情况。当block中需要用到self时或者说需要弱引用的时候，通过weak或者unsafe_unretained. 但是当需要强化的时候，比如说，在block中有延迟执行的操作的时候就必须将其弱化，需要用__strong来修饰就可以了 如果block体外面定义个一个int类型的a=10，在block体里面修改a = 20，此时a是多少，为什么，应该怎么做a是10，因为局部变量修饰的值，在block体里面取得是值，而不是地址，在后面无论怎么修改都是取到新的值，应该用__block来修饰，这样就是取地址了。（还有的面试官会问，假如在block体外面用static修饰的话或者是在头文件中定义这个a呢，这个时候记住一点，除了局部修饰的block外面的值是取值，别的都是取址都是可以发生改变的） 在block中有一个用GCD修饰的线程，需要延时加载，这个时候会不会有什么问题，该怎么操作。会可能出现野指针，也就是对象被提前释放了，是为了避免在 block 的执行过程中，突然出现 self 被释放的尴尬情况。通常情况下，如果不这么做的话，还是很容易出现一些奇怪的逻辑，甚至闪退.防止这个，需要用到__strong来强引用一下。在延迟之后需要用到的时候不会被释放掉。 第三方框架和原理 简述SDWebImage的实现原理（这个时候不要只是答文字，重要api需要说出来）1) 入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。2) 进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:3) 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。4) SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。5) 如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。6) 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。7) 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。8) SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。9) 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片, 回调 imageCache:didNotFindImageForKey:userInfo:。10) 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。11) 图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。12) connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。13) connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。14) 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。15) 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。16) 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。17) 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。 SDWebImage内部可以自己清理缓存吗？SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片 SDWebImage怎么预先下载图片，方便后续使用?提供了SDWebImagePrefetcher 可以预先下载图片，方便后续使用。 下拉刷新的原理（这个结合contentInset和contentOffset简单说说就可以了）大部分的下拉刷新控件，都是用contentInset实现的。默认情况下，如果一个UIScrollView的左上角在导航栏的正下方，那么它的contentInset是64，而contentOffset是-64。继续下拉的话，contentOffset就会越来越小，如果上滑，contentOffset就会增大，直到左上角达到屏幕的左上角时，contentOffset刚好为0默认情况下，如果下拉一个UIScrollView，在松手之后，会弹回初始的位置（导航栏下方）。而大部分的下拉刷新控件，都是将自己放在UIScrollView的上方，起始y设置成负数，所以平时不会显示出来，只有下拉的时候才会出现，放开又会弹回去。然后在loading的时候，临时把contentInset增大，相当于把UIScrollView往下挤，于是下拉刷新的控件就会显示出来，然后刷新完成之后，再把contentInset改回原来的值，实现回弹的效果 数据存储 为什么应用存在沙盒中iOS本地化存储的数据保存在沙盒中 ，每个应用的沙盒是独立，结构是相同的，这样比较安全（我没回答上来，面试官给说的答案，不知道正确性） 存储方式1）Plist存储：Plist文件的Type可以是字典NSDictionary或数组NSArray，也就是说可以把字典或数组直接写入到文件中。NSString、NSData、NSNumber等类型，也可以使用writeToFile:atomically:方法直接将对象写入文件中，只是Type为空。2）NSUserDefaults，一般的登录注册的数据保存这个里面3）NSKeyedArchiver归档 / NSKeyedUnarchiver解档4) 归档和解档会在写入、读出数据之前进行序列化、反序列化，数据的安全性相对高一些。&emsp;&emsp;1&gt; 对单个简单对象进行归档/解档，当然，也可以存储NSArray，NSDictionary等对象。&emsp;&emsp;2&gt; 对多个对象进行归档/解档&emsp;&emsp;3&gt; 归档保存自定义对象。定义一个Person类，如果想对person进行归档解档，首先要让Person遵守协议。4）SQLite3&emsp;&emsp;1&gt; 首先需要添加库文件libsqlite3.0.tbd&emsp;&emsp;2&gt; 导入头文件#import &lt;sqlite3.h&gt;&emsp;&emsp;3&gt; 打开数据库&emsp;&emsp;4&gt; 创建表&emsp;&emsp;5&gt; 对数据表进行增删改查操作&emsp;&emsp;6&gt; 关闭数据库 FMDB和CoraData的区别FMDB是oc方式来封装c语言的sqlite，还是需要编写sqlite语句，CoreData是oc方式来封装c语言的sqlite，不用编写任何sqlite语句，自动根据对象类型和属性名生成对应的sqlite语句这两个的区别：CoreData不用编写sqlite语句，CoreData是不可控的，以为自动生成，会有很多不必要的属性，FMDB可以自己控制。 用sql语句怎么增加或者删除一个字段1）增加表字段：ALTER TABLE 表名 ADD COLUMN字段名字段类型2）删除表字段：ALTER TABLE 表名 DROP COLUMN字段名 字段类型3）x修改表字段：ALTER TABLE 表名 RENAME COLUMN旧字段名 to 新字段名 沙盒中存储文件都包括什么，都是怎么存放的（有一个问了这个问题）1)Application :存放程序源文件，上架前经过数字签名，上架后不可修改2）Document：常用目录，iCloud备份目录，存放数据，这里不能缓存文件，否则上架不被通过3）Library：&emsp;&emsp;1&gt; Caches:存放 体积大又不需要备份的数据，SDWebImage缓存路径就是这个&emsp;&emsp;2&gt; Preference:设置目录，iCloud会备份设置信息4）tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能 Runloop（这个具体没什么问题，看文档吧） 定义RunLoop的实质是一个死循环，用于保证程序的持续运行，只有当程序退出的时候才会结束（由main函数开启主线程的RunLoop） 作用保持程序的持续运行处理App中的各种事件（触摸、定时器、Selector事件）节省CPU资源，提高程序性能（该做事做事，没事做休息）使用NSRunLoop（面向对象）或者CFRunLoopRef（底层C语言） RunLoop的原理RunLoop开启一个循环事件，并接受输入事件，接受的事件来自两种不同的来源：输入源（input source）(传递异步事件)定时源（timer source）(传递同步事件)RunLoop接收到消息后采用handlePort、customSrc、mySelector和timerFired四个方法处理对应的事件当RunLoop没有接收到消息时，则进入休眠状态，以保持程序持续运行 多线程 NSOperation和GCD的区别1）GCD是基于c的底层api，NSOperation属于object-c类。ios首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。2）GCD优点：GCD主要与block结合使用。代码简洁高效。执行效率稍微高点。3）NSOperation相对于GCD：&emsp;&emsp;1&gt;，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在GCD基础上实现的，只不过是GCD更高一层的抽象。&emsp;&emsp;2&gt;，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。&emsp;&emsp;3&gt;NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）&emsp;&emsp;4&gt;GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。4)使用NSOperation的情况：各个操作之间有依赖关系、操作需要取消暂停、并发管理、控制操作之间优先级，限制同时能执行的线程数量.让线程在某时刻停止/继续等。5)使用GCD的情况：一般的需求很简单的多线程操作，用GCD都可以了，简单高效。 设计模式 单例（这个需要会写，两种写法，好几次让手写1）写法一：//提供一个static修饰的全局变量，强引用着已经实例化的单例对象实例 123456789101112131415161718192021222324252627282930313233343536static FileManager* sharedInstance = nil;//类方法，返回一个单例对象+(FileManager*) sharedInstance&#123; @synchronized(self) &#123; if (sharedInstance == nil) &#123; sharedInstance = [[self alloc] init]; //注意：这里建议使用self,而不是直接使用类名Tools（考虑继承） &#125; &#125; return sharedInstance;&#125;//保证永远只分配一次存储空间+(id)allocWithZone:(NSZone *)zone&#123; //使用加锁的方式，保证只分配一次存储空间 @synchronized(self)&#123; if(sharedInstance == nil)&#123; sharedInstance = [super allocWithZone:zone]; return sharedInstance; // assignment and return on first allocation &#125; &#125; return nil; //on subsequent allocation attempts return nil&#125;//让代码更加的严谨-(id)copyWithZone:(NSZone *)zone&#123; return self;&#125;2）写法二用GCDstatic SwitchMenuViewModel * segTitles = nil;+(instancetype)sharedSegTitles&#123; static dispatch_once_t once; dispatch_once(&amp;once,^&#123; segTitles = [[SwitchMenuViewModel alloc]init]; &#125;); return segTitles;&#125; 通知NSNotification 是iOS中一个调度消息通知的类,采用单例模式设计,在程序中实现传值、回调等地方应用很广。在iOS中，NSNotification &amp; NSNotificationCenter是使用观察者模式来实现的用于跨层传递消息。对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变，也不知道对象是什么&emsp;&emsp;1&gt; 向观察者中心添加观察者 123456789101112131415161718192021222324252627282930313233-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self addNotifications];//添加通知&#125;-(void)addNotifications&#123; //退出企业 [[NSNotificationCenter defaultCenter] removeObserver:self name:NT_Exit_Company object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(ExitCompany:) name:NT_Exit_Company object:nil];&#125;// 移除通知-(void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self removeNotifications];//添加通知&#125;-(void)removeNotifications&#123; [[NSNotificationCenter defaultCenter]removeObserver:self name:NT_Exit_Company object:nil];&#125;&amp;emsp;&amp;emsp;2&gt; 通知中心向观察者发送消息[[NSNotificationCenter defaultCenter] postNotificationName:NT_Exit_Company object:dict];&amp;emsp;&amp;emsp;3&gt;实现通知之后的操作// 收到推送之后刷新界面-(void)RefreashHomeVC:(NSNotification *) obj&#123; lable = obj.object; [self ToDetectNetWork];//重新加载&#125; Runtimeruntime是一套底层的C语言API，是一个实现Objective-C语言的C库。它是一门编译型语言、也是一门动态型的语言（这里强调下OC是静态类型语言），OC之所以能够做到即是编译型语言，又能做到动态语言，就是得益于runtime的机制。所谓runtime机制就是在C语言里边的函数调用到了OC里边就变成了另外一个名字，称之为消息发送。即objc_msgSend，这就是利用了runtime的消息机制特性，完成了一个动态调用的过程。还有一个重要的作用，可以交换两个方法的实现，代码是：method_exchangeImplementations 性能优化 用ARC管理内存 在正确的地方使用 reuseIdentifier 尽量把views设置为透明 避免过于庞大的XIB 不要阻塞主线程 在Image Views中调整图片大小 选择正确的使用Collection 重用和延迟加载(lazy load) Views 避免日期格式转换 渲染方法 处理内存警告 避免反复处理数据 选择正确的数据格式 正确设定背景图片 减少使用Web特性 优化Table View 使用Autorelease Pool 选择是否缓存图片 NSTimer （这个被问的多） Nstimer计时一定是安全的吗，不安全怎么办答案是否定的，而且有时候你会发现实际的触发时间跟你想象的差距还比较大。NSTimer不是一个实时系统，因此不管是一次性的还是周期性的timer的实际触发事件的时间可能都会跟我们预想的会有出入。差距的大小跟当前我们程序的执行情况有关系，比如可能程序是多线程的，而你的timer只是添加在某一个线程的runloop的某一种指定的runloopmode中，由于多线程通常都是分时执行的，而且每次执行的mode也可能随着实际情况发生变化。假设你添加了一个timer指定2秒后触发某一个事件，但是签好那个时候当前线程在执行一个连续运算(例如大数据块的处理等)，这个时候timer就会延迟到该连续运算执行完以后才会执行。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会和后面的触发进行合并，即在一个周期内只会触发一次。但是不管该timer的触发时间延迟的有多离谱，他后面的timer的触发时间总是倍数于第一次添加timer的间隙 nstimer在使用的时候，应该注意什么1）必须得把timer添加到runloop中，它才会生效2）要让timer生效，必须保证该线程的runloop已启动，而且其运行的runloopmode也要匹配3）划动下面的tableview没有变化，是为什么？**经常被问到这个问题在tableview滑动时timer就是显示暂停，原因是timer的这个简便构造方法把timer加入了NSRunLoopDefaultMode上，而tableview在滑动时只会处理UITrackingRunLoopMode，RunLoop并没有处理timer事件。解决的办法是将timer绑定到NSRunLoopCommonModes上，通过以下方法构造timer：nstimer在使用的时候，应该注意什么 延伸问题: 什么是死锁，举例说明互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住比如下面的代码： 12345dispatch_sync(_queue, ^&#123; &amp;emsp;dispatch_sync(_queue, ^&#123; //do something &#125;);&#125;) frame和bounds的区别frame是指的该view在父view坐标系统中的位置和大小bounds是该view在本身坐标系统中的位置和大小 什么是三次握手（笔试）第一次握手：建立连接时，客户端发送同步序列编号到服务器，并进入发送状态，等待服务器确认第二次握手：服务器收到同步序列编号，确认并同时自己也发送一个同步序列编号，+确认标志，此时服务器进入接受状态第三次握手：客户端收到服务器发送的包，并向服务器发送确认标志，随后链接成功。 有a b c d 四个异步请求，如何在a b c 都完成之后去执行d 1234567891011121) 创建队列queue dispatch_queue_t queue = (dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0))2) 创建组group dispatch_group_t group = dispatch_group_creat();3) 将queue和group加入到执行的任务中 并执行a b cdispatch_group_async(group,queue,^&#123;//任务a&#125;)dispatch_group_async(group,queue,^&#123;//任务b&#125;)dispatch_group_async(group,queue,^&#123;//任务c&#125;)4) 完了之后引用dispatch_group_notify(group,dispatch_get_main_queue()),^&#123; //执行d操作&#125;);]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发常见bug]]></title>
    <url>%2F2018%2F03%2F26%2Fquestion%2F</url>
    <content type="text"><![CDATA[使用第三方框架Alamofire、Kingfisher 等等时报错dyld: Library not loaded Reason: image not found 在Xcode中的Build Phases中的Copy Files项中，将你要引用的framework拖到“Linked Frameworks and Libraries“中 把Build Phases 里Social.framework后边的选项修改成为Optional就可以了 Swift4.0 中使用KVC给model赋值时无法赋值 在model中给属性前添加@objc关键字 在iOS 11上给navigationBar的titleView添加searchBar导致navigationBar高度增高 自定义一个view，然后将searchBar添加到自定义view上，再将自定义view赋值给titleView UISearchBar进入编辑状态时向上偏移设置searchController.hidesNavigationBarDuringPresentation = NO; UISearchController取消遮盖蒙版设置searchController.dimsBackgroundDuringPresentation = NO; 如何监听UISearchController遮盖点击事件点击遮盖时就是将searchController隐藏、所以监听UISearchController消失的事件即可 (void)willDismissSearchController:(UISearchController *)searchController{ // TODO:} 解决tableView的sectionIndex和searchBar冲突问题把searchBar加在一个UIView上，然后把UIView加在tableHeaderView上，同时sectionIndex背景色要清除 UIView *headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kScreen_width, 56)];[headerView addSubview:self.searchController.searchBar];[self.tableView setTableHeaderView:headerView]; [self.tableView setSectionIndexBackgroundColor:[UIColor clearColor]];]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Coding.net/Github搭建自己的博客]]></title>
    <url>%2F2018%2F03%2F02%2FSetBlog%2F</url>
    <content type="text"><![CDATA[因为gitHub服务器在国外，而且gitHub不让百度的爬虫爬取内容，导致了搭建在gitHub上的博客访问速度非常慢，博客不会被百度搜索到。所以建议选择国内的Coding.net来搭建博客。搭建方法几乎是一致的。下面讲一下如何基于Coding.net搭建自己的博客。 安装Hexo1$ npm install hexo-cli -g 初始化blog1$ hexo init blog 启动预览blog12$ cd blog$ hexo server 在浏览器输入：http://localhost:4000/ 显示如下图就成功了 设置33种主题样式搭建博客大全]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>记事</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE HTML&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于本站]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[博客宗旨: 把最实用的经验，分享给最需要的读者，希望每一位来访的朋友都能有所收获！]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
